<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="jlearning.cn">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="jlearning.cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jlearning.cn">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> jlearning.cn </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jlearning.cn</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/29/ESN-basic-tutorial/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/29/ESN-basic-tutorial/" itemprop="url">
                  回声状态网络（ESN）基础教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-29T17:29:34+08:00">
                2017-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看回声状态网络（Echo State Network）的内容，注意到中文搜索引擎搜不到关于有关Echo State Network通俗的讲解，打算写一下关于ESN的一个基本教程。本文先用一小段简单介绍ESN是什么，然后用公式来表示这种网络，并说明他的优缺点，最后用一个可执行的简单例子来演示一下ESN的效果。</p>
<p>由于本人能力有限，如在阅读过程中有任何疑问或者发现错误请在评论中指出。</p>
<p>ESN是RNN的一种，也是由输入层，隐藏层，输出层组成，并且在隐藏层到隐藏层之间有一个连接，用来保留前面时刻留下的信息。不同于RNN，ESN的输入层到隐藏层、隐藏层到隐藏层的连接权值是随机初始化，并且固定不变。在训练的过程中，我们只需要去训练隐藏层到输出层的连接权值。这就变成了一个线性回归问题，所以ESN训练起来非常快。</p>
<p><img src="\images\ESN-basic-tutorial\微信截图_20170529161715.png" alt="微信截图_20170529161715"></p>
<p>ESN的神经网络如图所示，储备池就是常规神经网络中的隐藏层。输入层到储备池的连接为$W<em>{in}$，储备池到下一个时刻储备池状态的连接为W，储备池到输出层的连接为​$W</em>{out}$。另外还有一个前一时刻的输出层到下一个时刻的储备池的连接$W_{back}$，这个连接不是必须的（图中用虚线表示），由于这是一个入门级的基础教程，所以在后面的公式和例子代码中都不会涉及这一个连接。</p>
<p>图中所示，$t$时刻的输入为$u(t)$，一共K个节点，储备池状态为$x(t)$，N个节点，输出为$y(t)$，L个节点。</p>
<p>每一个时刻输入$u(t)$，储备池都会更新状态，储备池的状态更新方式为：</p>
<p>$$x(t+1)=f(W_{in}u(t+1)+Wx(t))$$</p>
<p>这个式子里，$W_{in}$和$W$都是在最初建立网络的时候随机初始化的，并且固定不变。$u(t+1)$是这个时刻的输入，$x(t)$是上一个时刻的储备池状态，在t=0时刻可以用0初始化。$f$是一个激活函数，通常使用$tanh$。</p>
<p>在建模的时候，和一般的神经网络一样，会在连接矩阵上加上一个偏置量，所以输入的$u$是一个长度为1+K的向量，$W_{in}$是一个[1+k,N]的矩阵，$x$是一个长度为N的向量，$W$是一个[N,N]的矩阵。</p>
<p>回声状态网络的输出方式为：</p>
<p>$$y(t)=W_{out}[1;u(t);x(t)]$$</p>
<p>有了储备池状态，再确定了ESN的输出方式之后，就可以根据目标输出$y^{target}$来确定$W_{out}$来让$y(t)$和$y^{target}(t)$的差距尽可能的小。这是一个简单的线性回归问题，计算的方法有很多种，不再赘述。</p>
<p><img src="\images\ESN-basic-tutorial\微信截图_20170529170125.png" alt="微信截图_20170529170125"></p>
<p>到这里，我们就完成了ESN的训练工作。整个网络只需要训练$W_{out}$，所以它的训练过程非常快，这是ESN的优点之一。另外，对于一维时序数列的处理和预测，ESN有很好的优势。但对于高维的时序数列，比如说视频帧处理，ESN就不太能胜任了。</p>
<p>为了让这个网络能够正常的运转，还有一些地方是需要注意的：</p>
<ol>
<li>之所以叫回声状态网络，是因为前面时刻输入的信息会通过$W$回回荡在储备池中，就像回声一样。为了避免储备池状态爆炸，$W$的特征值必须要小于等于1。这也就引入了ESN中<code>谱半径</code>的概念：$W$的最大特征值。</li>
<li>由于网络中只有$W_{out}$是可变的，为了尽可能多的表示不同的数据规律，$W$必须要设置的非常大，才能从中找出各种不同的特征进行输出。另一方面，$W$的稀疏性也很重要，Hinton在多伦多大学的公开课里解释是：</li>
</ol>
<blockquote>
<p>建立一个松散的连接，这样某一信息可以在网络中的一小部分回荡，而不会迅速的传播到其他部分。</p>
</blockquote>
<p>我不是特别的理解。希望有人解释一下。</p>
<p>最后引用<a href="http://minds.jacobs-university.de/mantas/code" target="_blank" rel="external">一个例子</a>来彻底理解最基本的ESN。</p>
<p>在页面中下载python源码和数据集，在python2.7环境中运行。</p>
<p>数据就是一维的，代码中每次输入长度为1，预测数据中后一位的值，当然长度也是1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="string">"""</span></div><div class="line">A minimalistic Echo State Networks demo with Mackey-Glass (delay 17) data </div><div class="line">in "plain" scientific Python.</div><div class="line">by Mantas LukoĹĄeviÄ?ius 2012</div><div class="line">http://minds.jacobs-university.de/mantas</div><div class="line">"""</div><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> *</div><div class="line"><span class="keyword">import</span> scipy.linalg</div><div class="line"></div><div class="line"><span class="comment"># load the data</span></div><div class="line"><span class="comment">#前2000个数据用来训练，2001-4000的数据用来测试。训练数据中，前100项用来初始化储备池，以让储备池中形成良好的回声之后再开始训练。</span></div><div class="line">trainLen = <span class="number">2000</span></div><div class="line">testLen = <span class="number">2000</span></div><div class="line">initLen = <span class="number">100</span></div><div class="line"></div><div class="line">data = loadtxt(<span class="string">'MackeyGlass_t17.txt'</span>)</div><div class="line"></div><div class="line"><span class="comment"># plot some of it</span></div><div class="line">figure(<span class="number">10</span>).clear()</div><div class="line">plot(data[<span class="number">0</span>:<span class="number">1000</span>])</div><div class="line">title(<span class="string">'A sample of data'</span>)</div><div class="line"></div><div class="line"><span class="comment"># generate the ESN reservoir</span></div><div class="line">inSize = outSize = <span class="number">1</span></div><div class="line">resSize = <span class="number">1000</span></div><div class="line">a = <span class="number">0.3</span> <span class="comment"># leaking rate 可以看作储备池更新的速度，可不不加，即设为1.</span></div><div class="line"></div><div class="line">random.seed(<span class="number">42</span>)</div><div class="line"><span class="comment">#随机初始化 Win 和 W</span></div><div class="line">Win = (random.rand(resSize,<span class="number">1</span>+inSize)<span class="number">-0.5</span>) * <span class="number">1</span></div><div class="line">W = random.rand(resSize,resSize)<span class="number">-0.5</span> </div><div class="line"><span class="comment">#对W进行防缩，以满足稀疏的要求。</span></div><div class="line"><span class="comment"># Option 1 - direct scaling (quick&amp;dirty, reservoir-specific):</span></div><div class="line"><span class="comment">#W *= 0.135 </span></div><div class="line"><span class="comment"># Option 2 - normalizing and setting spectral radius (correct, slow):</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Computing spectral radius...'</span>,</div><div class="line">rhoW = max(abs(linalg.eig(W)[<span class="number">0</span>]))</div><div class="line"><span class="keyword">print</span> <span class="string">'done.'</span></div><div class="line">W *= <span class="number">1.25</span> / rhoW</div><div class="line"></div><div class="line"><span class="comment"># allocated memory for the design (collected states) matrix</span></div><div class="line">X = zeros((<span class="number">1</span>+inSize+resSize,trainLen-initLen))</div><div class="line"><span class="comment"># set the corresponding target matrix directly</span></div><div class="line">Yt = data[<span class="keyword">None</span>,initLen+<span class="number">1</span>:trainLen+<span class="number">1</span>] </div><div class="line"></div><div class="line"><span class="comment">#输入所有的训练数据，然后得到每一时刻的输入值和储备池状态。</span></div><div class="line"><span class="comment"># run the reservoir with the data and collect X </span></div><div class="line">x = zeros((resSize,<span class="number">1</span>))</div><div class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(trainLen):</div><div class="line">    u = data[t]</div><div class="line">    x = (<span class="number">1</span>-a)*x + a*tanh( dot( Win, vstack((<span class="number">1</span>,u)) ) + dot( W, x ) )</div><div class="line">    <span class="keyword">if</span> t &gt;= initLen:</div><div class="line">        X[:,t-initLen] = vstack((<span class="number">1</span>,u,x))[:,<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="comment">#使用Wout根据输入值和储备池状态去拟合目标值，这是一个简单的线性回归问题，这里使用的是岭回归(Ridge Regression)。</span></div><div class="line"><span class="comment"># train the output</span></div><div class="line">reg = <span class="number">1e-8</span>  <span class="comment"># regularization coefficient</span></div><div class="line">X_T = X.T</div><div class="line">Wout = dot( dot(Yt,X_T), linalg.inv( dot(X,X_T) + \</div><div class="line">    reg*eye(<span class="number">1</span>+inSize+resSize) ) )</div><div class="line"><span class="comment">#Wout = dot( Yt, linalg.pinv(X) )</span></div><div class="line"></div><div class="line"><span class="comment">#使用训练数据进行前向处理得到结果</span></div><div class="line"><span class="comment"># run the trained ESN in a generative mode. no need to initialize here, </span></div><div class="line"><span class="comment"># because x is initialized with training data and we continue from there.</span></div><div class="line">Y = zeros((outSize,testLen))</div><div class="line">u = data[trainLen]</div><div class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(testLen):</div><div class="line">    x = (<span class="number">1</span>-a)*x + a*tanh( dot( Win, vstack((<span class="number">1</span>,u)) ) + dot( W, x ) )</div><div class="line">    y = dot( Wout, vstack((<span class="number">1</span>,u,x)) )</div><div class="line">    Y[:,t] = y</div><div class="line">    <span class="comment"># generative mode:生成模型</span></div><div class="line">    u = y</div><div class="line">    <span class="comment">## this would be a predictive mode:预测模型</span></div><div class="line">    <span class="comment">#u = data[trainLen+t+1] </span></div><div class="line"></div><div class="line"><span class="comment"># compute MSE for the first errorLen time steps</span></div><div class="line">errorLen = <span class="number">500</span></div><div class="line">mse = sum( square( data[trainLen+<span class="number">1</span>:trainLen+errorLen+<span class="number">1</span>] - Y[<span class="number">0</span>,<span class="number">0</span>:errorLen] ) ) / errorLen</div><div class="line"><span class="keyword">print</span> <span class="string">'MSE = '</span> + str( mse )</div><div class="line">    </div><div class="line"><span class="comment"># plot some signals</span></div><div class="line">figure(<span class="number">1</span>).clear()</div><div class="line">plot( data[trainLen+<span class="number">1</span>:trainLen+testLen+<span class="number">1</span>], <span class="string">'g'</span> )</div><div class="line">plot( Y.T, <span class="string">'b'</span> )</div><div class="line">title(<span class="string">'Target and generated signals $y(n)$ starting at $n=0$'</span>)</div><div class="line">legend([<span class="string">'Target signal'</span>, <span class="string">'Free-running predicted signal'</span>])</div><div class="line"></div><div class="line">figure(<span class="number">2</span>).clear()</div><div class="line">plot( X[<span class="number">0</span>:<span class="number">20</span>,<span class="number">0</span>:<span class="number">200</span>].T )</div><div class="line">title(<span class="string">'Some reservoir activations $\mathbf&#123;x&#125;(n)$'</span>)</div><div class="line"></div><div class="line">figure(<span class="number">3</span>).clear()</div><div class="line">bar( range(<span class="number">1</span>+inSize+resSize), Wout.T )</div><div class="line">title(<span class="string">'Output weights $\mathbf&#123;W&#125;^&#123;out&#125;$'</span>)</div><div class="line"></div><div class="line">show()</div></pre></td></tr></table></figure>
<p>实验结果是再生成模型的情况下，最后得到的均方差为 2.3*10^-5。</p>
<p>生成的结果与测试结果对比图：</p>
<p><img src="\images\ESN-basic-tutorial\微信截图_20170529172248.png" alt="微信截图_20170529172248"></p>
<p>再预测模型中，均方差为6.95*10^-8。</p>
<p>预测值与真实值的对比图为：</p>
<p><img src="\images\ESN-basic-tutorial\微信截图_20170529172425.png" alt="微信截图_20170529172425"></p>
<p>效果还是肥肠好的！</p>
<p>参考文献：</p>
<p>[1] Jaeger H. The “echo state” approach to analysing and training recurrent neural networks-with an erratum note[J]. Bonn, Germany: German National Research Center for Information Technology GMD Technical Report, 2001, 148(34): 13.</p>
<p>[2] Lukoševičius M. A practical guide to applying echo state networks[M]//Neural networks: Tricks of the trade. Springer Berlin Heidelberg, 2012: 659-686.</p>
<p>[3] 罗熊, 黎江, 孙增圻. 回声状态网络的研究进展[J]. 北京科技大学学报, 2012, 34(2):217-222.</p>
<p>[4] <a href="http://minds.jacobs-university.de/mantas/code" target="_blank" rel="external">http://minds.jacobs-university.de/mantas/code</a></p>
<p>[5] <a href="https://zh.coursera.org/learn/neural-networks/lecture/s1bdp/echo-state-networks-9-min" target="_blank" rel="external">https://zh.coursera.org/learn/neural-networks/lecture/s1bdp/echo-state-networks-9-min</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/27/java-Integer-Object-Compare/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/27/java-Integer-Object-Compare/" itemprop="url">
                  Java中Integer类的三种初始化方式和在逻辑运算上的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-27T21:15:09+08:00">
                2017-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近两次遇到Integer对象比较的问题，记录一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">		Integer a = <span class="keyword">new</span> Integer(<span class="number">1200</span>);</div><div class="line">		Integer b = <span class="keyword">new</span> Integer(<span class="number">1200</span>);</div><div class="line">		<span class="keyword">int</span> c = <span class="number">1200</span>;</div><div class="line">		<span class="keyword">int</span> d = <span class="number">1200</span>;</div><div class="line">		Integer e = <span class="number">1200</span>;</div><div class="line">		Integer f = <span class="number">1200</span>;</div><div class="line">		</div><div class="line">		Integer g = <span class="number">120</span>;</div><div class="line">		Integer h = <span class="number">120</span>;</div><div class="line">				</div><div class="line">				</div><div class="line">		System.out.println(a==b); <span class="comment">//false</span></div><div class="line">		System.out.println(a.equals(b));  <span class="comment">//true</span></div><div class="line">		</div><div class="line">		System.out.println(c==d);  <span class="comment">//true</span></div><div class="line">		<span class="comment">//System.out.println(c.equals(d));</span></div><div class="line">		</div><div class="line">		System.out.println(a==d);  <span class="comment">//true</span></div><div class="line">		System.out.println(a.equals(d));  <span class="comment">//true</span></div><div class="line">		</div><div class="line">		System.out.println(e==f);  <span class="comment">//false</span></div><div class="line">		System.out.println(e.equals(f));  <span class="comment">//true </span></div><div class="line">		</div><div class="line">		System.out.println(g==h);  <span class="comment">//true</span></div><div class="line">		System.out.println(g.equals(h));  <span class="comment">//true</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>几个知识点：</p>
<ol>
<li><code>==</code> 运算符在比较两个对象时，是在比较两个对象引用。所以<code>a</code>和<code>b</code>是两个对象，第一个是<code>false</code></li>
<li><code>.equals()</code>方法需要在类中重写，以比较类中的值，在<code>Integer</code>类中，很显然比较的就是int类型的值，所以第二个是<code>true</code></li>
<li>使用基本类型时，会在内存中产生重用，所以当两次使用<code>int</code>初始化<code>c</code>和<code>d</code>时，实际上使用的是相同的地址。第三个<code>true</code></li>
<li>使用<code>==</code>比较<code>int</code>和<code>Integer</code>时，会自动拆箱，所以第四是<code>true</code>。第五个也是对的。</li>
<li>比较6和8的不同，这里要知道<code>Integer e = 1200</code>等价于<code>Integer e = Integer.valueOf(1200)</code>，看JDK的源码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">  <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">  <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">  	<span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于-128-127之间的数，会进行缓存，下次再初始化时会从缓存中取，而不是new一个。</p>
<ol>
<li>另外再补充一个，用<code>==</code>比较<code>Integer</code>和<code>new Integer</code>的时候，也不会自动拆箱，所以比较的是两个对象引用，所以是false。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/Atomic-and-nonblocking-synchronized/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/Atomic-and-nonblocking-synchronized/" itemprop="url">
                  Java并发性能提升的关键——原子变量与非阻塞同步机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-15T22:04:23+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从这本书的最开始，就接触到原子变量类——<code>AtomicInteger</code>和<code>AtomicReference</code>用于代替锁来实现对安全性的保障。这就是从Java5.0开始的使用原子变量来提供相比较<code>synchronized</code>机制更好的性能和可伸缩性。除此之外，非阻塞的同步机制也能提供这样的良好体验。</p>
<h3 id="锁的劣势"><a href="#锁的劣势" class="headerlink" title="锁的劣势"></a>锁的劣势</h3><ol>
<li>当线程恢复执行时，必须等待其他线程执行完它们的时间片。在挂起和回复线程过程中存在着很大的开销，通常存在较长时间的中断。如果在类中操作量很小，调度开销和工作开销的比值会非常高。</li>
<li>一个线程在等待锁的时候，不能做任何事情。如果持有锁的进程被延迟执行（缺页错误，调度延迟等），其他需要这个锁的线程都无法执行下去。</li>
<li>如果被阻塞的线程优先级较高，持有锁的线程优先级较低，会产生优先级反转。</li>
<li>如果持有锁的线程被永久的阻塞（死循环，死锁，活锁等），程序永远无法执行下去。</li>
</ol>
<p>所以需要一种支持volatile变量的可见性，又支持原子性的机制。</p>
<h3 id="硬件对并发的支持"><a href="#硬件对并发的支持" class="headerlink" title="硬件对并发的支持"></a>硬件对并发的支持</h3><p>现代的处理器提供了既有volatile的可见性，又有原子性的支持。</p>
<p>早期的处理器支持原子的测试并设置(Test-and-Set)、获取并递增(Fetch-and-Increment)和交换(Swap)指令。现在几乎所有的现代处理器中都包含了<strong>原子读-改-写</strong>的指令。例如比较并交换(Compare-and-Swap)，关联加载/条件存储(Load-Linked/Store-Conditional)。</p>
<h4 id="比较并交换（CAS）"><a href="#比较并交换（CAS）" class="headerlink" title="比较并交换（CAS）"></a>比较并交换（CAS）</h4><p>CAS中包含三个操作数——需要读写的内存位置V、进行比较的值A、拟写入的新值B。V的值等于A时，用B来更新V的值，然后返回V的原有值。</p>
<p>当多个线程同时是哟个CAS更新一个变量时，只有一个线程能更新，其他线程都会失败。失败的线程不会被挂起，而是被告知失败，并可以再次尝试。</p>
<h4 id="非阻塞的计数器"><a href="#非阻塞的计数器" class="headerlink" title="非阻塞的计数器"></a>非阻塞的计数器</h4><p>使用CAS实现，读取旧值，加1，使用CAS来设置这个新值。如果CAS失败，立即重试。不会发生阻塞，但是如果多个线程同时更新，会多次执行重试。</p>
<p>在竞争程度不高时，基于CAS的计数器性能上远远超过基于锁的计数器。CAS的主要缺点是：它将使调用者处理竞争问题（重试、回退、放弃），而在锁中能自动处理竞争问题。（阻塞）</p>
<h3 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h3><ol>
<li>更新原子变量的快速路径（非竞争）不会比获取锁的快速路径慢，而它的慢速路径肯定比锁的慢速路径快，因为不需要挂起或重新调度线程。</li>
<li>在发生竞争的情况下，能提供更高的可伸缩性，因为直接利用了硬件对并发的支持。</li>
</ol>
<h3 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h3><p>在基于锁的算法中可能会发生各种活跃性故障，如果线程在持有锁时由于阻塞IO内存缺页等导致推迟执行，那么很可能所有线程都不能继续执行下去。<strong>如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。</strong></p>
<h4 id="非阻塞的栈"><a href="#非阻塞的栈" class="headerlink" title="非阻塞的栈"></a>非阻塞的栈</h4><p>push方法创建一个新的节点，该节点的next域只想当前的栈顶，然后使用CAS把这个新节点放入栈顶。如果在开始插入节点之前，位于栈顶的节点没有发生变化，那么CAS成功，如果栈顶节点发生了变化，失败，而push方法会根据栈的当前状态来更新节点，并且再次尝试。</p>
<h4 id="非阻塞的链表"><a href="#非阻塞的链表" class="headerlink" title="非阻塞的链表"></a>非阻塞的链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(E item)</span></span>&#123;</div><div class="line">  Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(item,<span class="keyword">null</span>);</div><div class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    Node&lt;E&gt; curTail = tail.get();</div><div class="line">    Node&lt;E&gt; tailNext = curTail.next.get();</div><div class="line">    <span class="keyword">if</span>(curTail == tail.get())&#123;</div><div class="line">      <span class="keyword">if</span>(tailNext!=<span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//队列处于中间状态（添加了尾节点，但是尾结点的指针没有指过去，推进尾结点）</span></div><div class="line">        tail.compareAndSet(curTail,tailNext);</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//处于稳定状态，尝试插入新节点</span></div><div class="line">        <span class="keyword">if</span>(curTail.next.compareAndSer(<span class="keyword">null</span>,newNode))&#123;</div><div class="line">          <span class="comment">//插入操作成功，尝试推进尾结点</span></div><div class="line">          tail.compareAndSer(curTail,newNode);</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/11/outer-sort/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/11/outer-sort/" itemprop="url">
                  《数据结构与算法设计》读书笔记——外部排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-11T20:58:07+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上个月在某养猪场面试，面试官问了一个问题：“如何用256M内存的机器对一个2G的数据进行排序”。之前没看过这方面的内容，想了一下说用<em>归并排序</em>，然后简略的说了一下我的想法。现在再来看书里关于外部排序的内容，只能说当时的大方向没错，但是剩下的具体实现、外部空间复杂度计算、时间复杂度计算和优化等都没考虑到位。</p>
<p>因为计算机的外部访问是非常慢的（相对比从内存读数据），如果使用和“把数据全部读入内存然后排序”相同的算法，再加上外部存储例如磁带是只能顺序访问，那么任何算法都需要$\Omega(N^2)$次外部数据访问，将是非常可怕的耗时。所以需要有专门用于外部排序的算法。</p>
<p>下面首先第一部分介绍基于归并排序的简单算法，然后第二部分在简单算法的基础上让其支持多路归并可以提高效率，第三部分首先在简单算法上应用多相合并，可以节约外部存储的空间，然后扩展到多路归并上，第四部分针对用于归并的顺串进行改造，在特定的情况下可以提高算法效率。</p>
<h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><p>使用归并排序的思想，简单的双路归并需要四盘磁带（就是外部存储）。最初的数据在$T_{a1}$上，内存为M，就是每次可以使用排序算法对M个数据进行排序。</p>
<ol>
<li>依次从$T_{a1}$上读入M数据，进行排序。</li>
<li>然后交替的输出到Tb1和Tb2上。每组排过序的记录叫做一个<em>顺串</em>。</li>
<li>将 Tb1和Tb2的第一个顺串取出来将两者合并（过程参考归并算法），将结果输出到$T_{a1}$上。</li>
<li>继续上一个步骤，交替的输出到Ta1和Ta2上。直到Tb1或Tb2为空。如果剩下一个顺串，拷贝到适当的磁带上。</li>
<li>这样我们在Ta1和Ta2上得到长度为M的顺串，重复上面的过程，知道得到长度为N的顺串。</li>
</ol>
<p>示例：</p>
<p>初始状态：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th>81 94 11 96 12 35 17 99 28 58 41 75 15</th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b2}$</td>
</tr>
</tbody>
</table>
<p>第1，第2步之后：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td>11 81 94</td>
<td>17 28 99</td>
<td>15</td>
</tr>
<tr>
<td>$T_{b2}$</td>
<td>12 35 96</td>
<td>41 58 75</td>
</tr>
</tbody>
</table>
<p>第3，第4步之后：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th>11 12 35 81 94 96</th>
<th>15</th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td>17 28 41 58 75 99</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$T_{b2}$</td>
<td></td>
</tr>
</tbody>
</table>
<p>重复这个从Ta1 Ta2归并到Tb1 Tb2，从Tb1 Tb2归并到Ta1 Ta2的过程：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td>11 12 17 28 35 51 58 75 81 94 96 99</td>
</tr>
<tr>
<td>$T_{b2}$</td>
<td>15</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th>11 12 15 17 28 35 51 58 75 81 94 96 99</th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b2}$</td>
</tr>
</tbody>
</table>
<p>完成！</p>
<p>我们“从Ta1 Ta2归并到Tb1 Tb2，从Tb1 Tb2归并到Ta1 Ta2”这个过程用了3趟。因为第一次顺串的长度为M，在二路归并的情况下，每次将顺串的长度延长一倍，需要$\lceil log_2(N/M)\rceil$趟。</p>
<h3 id="多路合并"><a href="#多路合并" class="headerlink" title="多路合并"></a>多路合并</h3><p>上面的简单算法就是二路合并，我们将其扩展到一般状态——k路合并。</p>
<p>k路合并需要2k盘磁带，每次将顺串的长度扩充为原来的k倍。在合并的时候，在k个元素中发现最小值是比二路合并复杂的地方，可以使用优先队列。多路合并和二路合并区别不大，就不举例子了。k路合并需要的趟数是$\lceil log_k(N/M)\rceil$</p>
<h3 id="多相合并"><a href="#多相合并" class="headerlink" title="多相合并"></a>多相合并</h3><p>在上面的多路合并中，k-路合并需要2k盘磁带。使用多相合并后，只使用2k-1盘磁带也可以达到相同的效果，可以节省外部存储空间。下面看如何用三盘磁带完成2-路合并：</p>
<ol>
<li>$T_1$上有34个顺串长度的数据，可以选择排序后在$T_2$$T_3$上分别输出17个顺串。</li>
<li>合并输出到$T _1$上，$T_1$上有17个顺串。</li>
<li>将8个顺串从$T_1$拷贝到$T_2$上，然后合并到$T_3$上，这时候$T_3$有9个顺串。</li>
<li>每次拷贝二分之一个顺串到一个空的磁带上，然后合并到剩下的那个空的磁带上。</li>
</ol>
<p>可以优化一下，让每次合并完成之后天然形成两个磁带有顺串，一个为空的情景：</p>
<ol>
<li>把$T_1$上的数据排序后，把21个顺串放到$T_2$上面，13个放到$T_3$上。</li>
<li>合并之后，$T_3$为空，$T_1$上有13个顺串，$T_2$上有8个顺串。</li>
<li>合并，$T_2$空，$T_3$上有8个顺串，$T_1$上有5个。重复这个过程。</li>
</ol>
<p>第一步分配的策略是：如果总顺串的数量是斐波那契数$F_N$,那么将顺串分解成F(N-1)和 F(N-2)。如果不是斐波那契数，需要用一些<em>哑顺串</em>(dummy run)来填补磁带。</p>
<p>将上面三盘磁带完成2-路合并扩展到k-路的多相合并，顺串分解使用k阶斐波那契数列：</p>
<p>$$F^{(k)}(N)=F^{(k)}(N-1)+F^{(k)}(N-2)+……+F^{(k)}(N-k)$$</p>
<p>$$F^{(k)}(N)=0,0\le k-2$$</p>
<p>$$F^{(k)}(k-1)=1$$</p>
<p>5阶斐波那契数列就是：</p>
<p>0，0，0，0，1，1，2，4，8，16，31，61……</p>
<h3 id="替换选择"><a href="#替换选择" class="headerlink" title="替换选择"></a>替换选择</h3><p>上面的排序算法中，第一步顺串的生成都使用了常规内存排序的方法，每次可以生成和内存容量一样大的有序数列。在<em>替换选择</em>算法中，无序数列平均可以生成2M长度的顺串。</p>
<ol>
<li>M个数据被读入内存，并放到一个优先队列中。执行一次DeleteMin把最小记录输出到磁带上。</li>
<li>内存空出一个位置，在从磁带读入下一个记录，如果比刚刚输出的数据要大，放入优先队列。否则把这个新元素存入优先队列的<em>死区</em>(dead space)。</li>
<li>重复上一个步骤，知道优先队列的大小为0，结束第一个顺串的构造。</li>
<li>使用死区中的所有元素建立一个新的优先队列，重复1，2，3的过程。</li>
</ol>
<p>替换选择在一些情况下，如果说大部分的数都是逆序的，效果并不比表标准算法好。但是，如果输入数据是大致顺序的，那么可以第一步就产生很长的顺串，减少来回归并的趟数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/11/structuring-your-TensorFlow-Model/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/11/structuring-your-TensorFlow-Model/" itemprop="url">
                  如何重构TensorFlow模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-11T20:56:34+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="构建你的TensorFlow模型"><a href="#构建你的TensorFlow模型" class="headerlink" title="构建你的TensorFlow模型"></a>构建你的TensorFlow模型</h2><p>翻译自：<a href="http://danijar.com/structuring-your-tensorflow-models/" target="_blank" rel="external">http://danijar.com/structuring-your-tensorflow-models/</a></p>
<p>Defining your models in TensorFlow can easily result in one huge wall of code. How to structure your code in a readable and reusable way? For the inpacient of you, here is the link to a <a href="https://gist.github.com/danijar/8663d3bbfd586bffecf6a0094cd116f2" target="_blank" rel="external">working example gist</a>.</p>
<p>第一句话不会翻译”wall of code”，算了，这不重要。</p>
<h3 id="定义计算图-Compute-Graph"><a href="#定义计算图-Compute-Graph" class="headerlink" title="定义计算图(Compute Graph)"></a>定义计算图(Compute Graph)</h3><p>每个模型使用一个类作为开始是非常明智的。类的接口是什么？通常，你的模型连接一些输入数据和目标<code>placeholders</code>，并且提供训练、测试的操作和接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, target)</span>:</span></div><div class="line">        data_size = int(data.get_shape()[<span class="number">1</span>])</div><div class="line">        target_size = int(target.get_shape()[<span class="number">1</span>])</div><div class="line">        <span class="comment">#truncated_normal返回正态分布的随机值</span></div><div class="line">        weight = tf.Variable(tf.truncated_normal([data_size, target_size]))</div><div class="line">        bias = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[target_size]))</div><div class="line">        incoming = tf.matmul(data, weight) + bias</div><div class="line">        self._prediction = tf.nn.softmax(incoming)</div><div class="line">        <span class="comment">#计算交叉熵，reduce_sum还能这样用？和文档写的不一样啊。</span></div><div class="line">        cross_entropy = -tf.reduce_sum(target, tf.log(self._prediction))</div><div class="line">        <span class="comment">#使用RMSPropOptimizer以0.03为learning rate最小化交叉熵</span></div><div class="line">        self._optimize = tf.train.RMSPropOptimizer(<span class="number">0.03</span>).minimize(cross_entropy)</div><div class="line">        mistakes = tf.not_equal(</div><div class="line">            tf.argmax(target, <span class="number">1</span>), tf.argmax(self._prediction, <span class="number">1</span>))</div><div class="line">        <span class="comment">#求平均误差</span></div><div class="line">        self._error = tf.reduce_mean(tf.cast(mistakes, tf.float32))</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prediction</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._prediction</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._optimize</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._error</div></pre></td></tr></table></figure>
<p>这基本上是在TensorFlow中定义模型的基础代码。但是他有一些问题。最值得注意的是，这个图在单个函数（构造函数）中定义，非常不具备可读性和可重用性。</p>
<h3 id="使用属性"><a href="#使用属性" class="headerlink" title="使用属性"></a>使用属性</h3><p>仅仅将代码分割在函数中是不行的，因为每次函数被调用的时候，图都会被新的代码扩展。因此，我们需要确保这些操作只有在函数第一次调用的时候才添加到图里面。这就是基本的惰性加载。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, target)</span>:</span></div><div class="line">        self.data = data</div><div class="line">        self.target = target</div><div class="line">        self._prediction = <span class="keyword">None</span></div><div class="line">        self._optimize = <span class="keyword">None</span></div><div class="line">        self._error = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prediction</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._prediction:</div><div class="line">            data_size = int(self.data.get_shape()[<span class="number">1</span>])</div><div class="line">            target_size = int(self.target.get_shape()[<span class="number">1</span>])</div><div class="line">            weight = tf.Variable(tf.truncated_normal([data_size, target_size]))</div><div class="line">            bias = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[target_size]))</div><div class="line">            incoming = tf.matmul(self.data, weight) + bias</div><div class="line">            self._prediction = tf.nn.softmax(incoming)</div><div class="line">        <span class="keyword">return</span> self._prediction</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._optimize:</div><div class="line">            cross_entropy = -tf.reduce_sum(self.target, tf.log(self.prediction))</div><div class="line">            optimizer = tf.train.RMSPropOptimizer(<span class="number">0.03</span>)</div><div class="line">            self._optimize = optimizer.minimize(cross_entropy)</div><div class="line">        <span class="keyword">return</span> self._optimize</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._error:</div><div class="line">            mistakes = tf.not_equal(</div><div class="line">                tf.argmax(self.target, <span class="number">1</span>), tf.argmax(self.prediction, <span class="number">1</span>))</div><div class="line">            self._error = tf.reduce_mean(tf.cast(mistakes, tf.float32))</div><div class="line">        <span class="keyword">return</span> self._error</div></pre></td></tr></table></figure>
<p> 这比第一个例子中的代码好多了。你的代码现在被构建在函数中，你现在可以分别关注他们。但是，由于延迟加载逻辑，代码仍然有一些臃肿。下面让我们改正它。</p>
<h3 id="惰性属性装饰器"><a href="#惰性属性装饰器" class="headerlink" title="惰性属性装饰器"></a>惰性属性装饰器</h3><p>python是一个相当灵活的语言。现在让我想你展示如何剔除上一段代码中的冗余代码。我们将使用一个行为就像<code>@property</code>一样的装饰器，但是只执行函数一次。他会在被装饰的函数后面将结果储存在一个命名成员中，而且后面的调用中返回结果。如果你还没有用过自定义装饰器，你可能需要看一下这个<a href="http://blog.apcelent.com/python-decorator-tutorial-with-example.html" target="_blank" rel="external">教程</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_property</span><span class="params">(function)</span>:</span></div><div class="line">    attribute = <span class="string">'_cache_'</span> + function.__name__</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line"><span class="meta">    @functools.wraps(function)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, attribute):</div><div class="line">            setattr(self, attribute, function(self))</div><div class="line">        <span class="keyword">return</span> getattr(self, attribute)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p>使用这个装饰器后，我们的例子简化成为下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, target)</span>:</span></div><div class="line">        self.data = data</div><div class="line">        self.target = target</div><div class="line">        self.prediction</div><div class="line">        self.optimize</div><div class="line">        self.error</div><div class="line"></div><div class="line"><span class="meta">    @lazy_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prediction</span><span class="params">(self)</span>:</span></div><div class="line">        data_size = int(self.data.get_shape()[<span class="number">1</span>])</div><div class="line">        target_size = int(self.target.get_shape()[<span class="number">1</span>])</div><div class="line">        weight = tf.Variable(tf.truncated_normal([data_size, target_size]))</div><div class="line">        bias = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[target_size]))</div><div class="line">        incoming = tf.matmul(self.data, weight) + bias</div><div class="line">        <span class="keyword">return</span> tf.nn.softmax(incoming)</div><div class="line"></div><div class="line"><span class="meta">    @lazy_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(self)</span>:</span></div><div class="line">        cross_entropy = -tf.reduce_sum(self.target, tf.log(self.prediction))</div><div class="line">        optimizer = tf.train.RMSPropOptimizer(<span class="number">0.03</span>)</div><div class="line">        <span class="keyword">return</span> optimizer.minimize(cross_entropy)</div><div class="line"></div><div class="line"><span class="meta">    @lazy_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></div><div class="line">        mistakes = tf.not_equal(</div><div class="line">            tf.argmax(self.target, <span class="number">1</span>), tf.argmax(self.prediction, <span class="number">1</span>))</div><div class="line">        <span class="keyword">return</span> tf.reduce_mean(tf.cast(mistakes, tf.float32))</div></pre></td></tr></table></figure>
<p>注意，我们提到构造函数中的属性。这样可以确保完整的图在我们执行<code>tf.initialize_variables()</code>时被定义。</p>
<h3 id="通过命名空间组织图"><a href="#通过命名空间组织图" class="headerlink" title="通过命名空间组织图"></a>通过命名空间组织图</h3><p>我们现在已经有一个清晰的方式去定义我们的模型，但是导致计算图非常拥挤。如果你想对图进行可视化，他将会有用很多互联的小节点。现在要在每个函数外面包裹<code>tf.name_scope(&#39;name&#39;)</code>或者<code>tf.varizble_scope(&#39;name&#39;)</code>。节点将会在图中分组。我们可以调整我们前面的装饰器去自动实现这些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">define_scope</span><span class="params">(function)</span>:</span></div><div class="line">    attribute = <span class="string">'_cache_'</span> + function.__name__</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line"><span class="meta">    @functools.wraps(function)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, attribute):</div><div class="line">            <span class="keyword">with</span> tf.variable_scope(function.__name):</div><div class="line">                setattr(self, attribute, function(self))</div><div class="line">        <span class="keyword">return</span> getattr(self, attribute)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p>我给这个装饰器一个新的名字（define_scope），因为除了添加惰性缓存之外他还有针对RensorFlow的特定功能。除此之外，这个模型看上去和前一个一样。</p>
<p>我们可以进一步的允许<code>@define_scope</code>装饰器forward arguments to the <code>tf.variable_scope()</code>，例如定义一个命名空间内的默认的初始化器(initializer)。可以参考作者上传的完整版代码：<a href="https://gist.github.com/danijar/8663d3bbfd586bffecf6a0094cd116f2" target="_blank" rel="external">https://gist.github.com/danijar/8663d3bbfd586bffecf6a0094cd116f2</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/05/avoid-deadlock/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/05/avoid-deadlock/" itemprop="url">
                  《Java并发编程实战》读书笔记——避免活跃性问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-05T16:45:17+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了让并发程序安全，会选择加锁。但是过度、不恰当的加锁会导致“锁顺序死锁”。同样，使用线程池和信号量来限制对资源的使用，这些被限制的行为可能导致“资源死锁”。这一章会主要介绍死锁的分类，主要根据死锁产生的原因进行分类。和如何避免和诊断死锁。最后介绍死锁之外的其他活跃性风险，比如说饥饿等。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>一个资源每次只能被一个人使用（互斥条件），每个人都拥有其他人需要的资源，同时又等待其他人已经拥有的资源（请求与保持条件），并且在每个人在获得所有需要的资源之前都不放弃已经拥有的资源（不剥夺条件）。（循环等待）就产生了死锁。</p>
<h4 id="锁顺序死锁"><a href="#锁顺序死锁" class="headerlink" title="锁顺序死锁"></a>锁顺序死锁</h4><p>两个线程试图用不同的顺序来获得相同的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadLock</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(left)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(right)&#123;</div><div class="line">        doSomething();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(right)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(left)&#123;</div><div class="line">        doSomethind();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要想验证锁顺序的一致性，需要对程序中的加锁行为进行全局分析。</p>
<h4 id="动态的锁顺序死锁"><a href="#动态的锁顺序死锁" class="headerlink" title="动态的锁顺序死锁"></a>动态的锁顺序死锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount, Account toAccount, DollarAmount amount)</span></span></div><div class="line">  <span class="keyword">throws</span> InsufficientFundsException&#123;</div><div class="line">    <span class="keyword">synchronized</span>(fromAccount)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(toAccount)&#123;</div><div class="line">        <span class="keyword">if</span>(fromAccount.getBalance().comparaTo(amount)&lt;<span class="number">0</span>)</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">          fromAccount.debit(amount);</div><div class="line">          toAccount.credit(amount);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>虽然锁顺序都是先取得<code>fromAccount</code>的锁，在取得<code>toAccount</code>的锁，但是事实上上锁的顺序取决于传递给函数的参数的顺序。</p>
<p>这种死锁可以通过制定锁的顺序来解决。使用<code>System.identityHashCode</code>方法，每次先获得<code>hashCode</code>小的那个对象的锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object tieLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMonet</span><span class="params">(<span class="keyword">final</span> Account fromAcct,<span class="keyword">final</span> Account toAcct, <span class="keyword">final</span> DollarAmount amount)</span> <span class="keyword">throws</span> insufficientFundsException</span>&#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Helper</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> <span class="keyword">throws</span> InsufficientFundsException</span>&#123;</div><div class="line">      <span class="keyword">if</span>(fromAcct.getBalance().comparaTo(amount)&lt;<span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> insufficientFundsException();</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        fromAcct.debit(amount);</div><div class="line">        toAcct.credit(amount);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">int</span> fromHash = System.identityHashCode(fromAcct);</div><div class="line">  <span class="keyword">int</span> toHash = System.identityHashCode(toAcct);</div><div class="line">  </div><div class="line">  <span class="keyword">if</span>(fromHash&lt;toHash)&#123;</div><div class="line">    <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">        <span class="keyword">new</span> Helper().transfer();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(from Hash&gt;toHash)&#123;</div><div class="line">    <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">        <span class="keyword">new</span> Helper().transfer();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//极少数的情况下，两个对象拥有相同的散列值，此时通过另一个锁保证每次只有一个线程以位置的顺序获得这两个锁。如果经常出先散列冲突的情况，这个地方因为相当于给整个程序加一个锁，会成为性能瓶颈。</span></div><div class="line">    <span class="keyword">synchronized</span>(tieLock)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">        <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">          <span class="keyword">new</span> Helper().transfer();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果每个账户都包含唯一不可变的可比的键值，会更简单，不用比较散列值。</p>
<h4 id="在协作对象之间发生的死锁"><a href="#在协作对象之间发生的死锁" class="headerlink" title="在协作对象之间发生的死锁"></a>在协作对象之间发生的死锁</h4><p>在持有锁的情况下调用某个外部方法，这个外部方法中可能会获取其他锁。可能会像锁顺序死锁一样。</p>
<h4 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h4><p>如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。</p>
<p>使用同步代码块仅被用于保护那些设计共享状态的操作。</p>
<h4 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h4><p>如果某些任务需要等待其他任务的结果，妈么这些任务往往是产生线程饥饿死锁的主要来源。</p>
<h3 id="死锁的避免与诊断"><a href="#死锁的避免与诊断" class="headerlink" title="死锁的避免与诊断"></a>死锁的避免与诊断</h3><p>如果程序每次最多只获得一个锁，那么就不会发生死锁。但是不现实。所以应该在设计时考虑锁的顺序，尽量减少潜在的加锁交互数量。</p>
<p>两阶段策略（Two-Part Strategy）：</p>
<ul>
<li>找出在什么地方将获取多个锁。</li>
<li>多所有这些实例进行全局分析，确保他们在整个程序中获取锁的顺序都是一致的。</li>
</ul>
<h4 id="支持定时的锁"><a href="#支持定时的锁" class="headerlink" title="支持定时的锁"></a>支持定时的锁</h4><p>显式使用Lock类中的定时tryLock功能来代替内置锁机制。显式锁可以指定一个超时时限，等待超过该事件后会返回一个失败信息。</p>
<h4 id="通过线程转储（Thread-Dump）信息来分析死锁"><a href="#通过线程转储（Thread-Dump）信息来分析死锁" class="headerlink" title="通过线程转储（Thread Dump）信息来分析死锁"></a>通过线程转储（Thread Dump）信息来分析死锁</h4><h3 id="其他活跃性问题"><a href="#其他活跃性问题" class="headerlink" title="其他活跃性问题"></a>其他活跃性问题</h3><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>当前线程由于无法访问它需要的资源而不能继续执行，就发生了饥饿。最典型的是由于错误的使用线程优先级，导致获取不到CPU时钟周期。</p>
<h4 id="糟糕的响应性"><a href="#糟糕的响应性" class="headerlink" title="糟糕的响应性"></a>糟糕的响应性</h4><p>CPU密集型后台任务与事件线程竞争CPU的时钟周期，从而影响响应性。</p>
<p>可以通过降低后台任务的优先级解决这个问题。</p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>错误的将不可修复的错误作为可修复的错误，导致如果不能成功处理某个消息，那么就回滚并重新放到队列开头，反复调用返回相同的结果。</p>
<p>当多个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行。就发生了活锁。</p>
<p>需要在重试机制中引入随机性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/04/difference-between-tf-Variable-and-tf-get-variable/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/04/difference-between-tf-Variable-and-tf-get-variable/" itemprop="url">
                  TensorFlow——tf.Variable和tf.get_variable()的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-04T16:18:43+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基础用法的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var1 = tf.get_variable(<span class="string">"var3"</span>,[<span class="number">1</span>])</div><div class="line">sess.run(tf.global_variables_initializer())</div><div class="line">var1.eval()</div><div class="line"><span class="comment">#输出：array([-1.57205701], dtype=float32)</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">W = tf.Variable([<span class="number">.3</span>], tf.float32)</div><div class="line">b = tf.Variable([<span class="number">-.3</span>], tf.float32)</div><div class="line">x = tf.placeholder(tf.float32)</div><div class="line">linear_model = W * x + b</div><div class="line">init = tf.global_variables_initializer()</div><div class="line">sess.run(init)</div><div class="line">print(sess.run(linear_model, &#123;x:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;))</div><div class="line"><span class="comment">#输出 [ 0.          0.30000001  0.60000002  0.90000004]</span></div></pre></td></tr></table></figure>
<p>看看文档怎么说：</p>
<blockquote>
<p>tf.get_variable:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; get_variable(</div><div class="line">&gt;     name,</div><div class="line">&gt;     shape=<span class="keyword">None</span>,</div><div class="line">&gt;     <span class="comment">#变来那个类型，默认DT_FLOAT</span></div><div class="line">&gt;     dtype=<span class="keyword">None</span>,</div><div class="line">&gt;     initializer=<span class="keyword">None</span>,</div><div class="line">&gt;     regularizer=<span class="keyword">None</span>,</div><div class="line">&gt;     trainable=<span class="keyword">True</span>,</div><div class="line">&gt;     collections=<span class="keyword">None</span>,</div><div class="line">&gt;     caching_device=<span class="keyword">None</span>,</div><div class="line">&gt;     partitioner=<span class="keyword">None</span>,</div><div class="line">&gt;     validate_shape=<span class="keyword">True</span>,</div><div class="line">&gt;     use_resource=<span class="keyword">None</span>,</div><div class="line">&gt;     custom_getter=<span class="keyword">None</span></div><div class="line">&gt; )</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>通过参数得到一个已经存在的变量，或者创建一个新的变量。</p>
<p>如果<code>initializer</code>是<code>None</code>，将会应用变来那个空间(variable scope)的默认<code>initilizer</code>。如果这个也是<code>None</code>，将会应用<code>glorot_uniform_initializer</code>。<code>initializer</code>也可以是一个<code>Tensor</code>，在这种情况下，变来那个将会被初始化为这个值和这个<code>shape</code>。</p>
</blockquote>
<p>所以，<code>glorot_uniform_initializer</code>是什么？在文档里搜了一下，搜不到。最接近的是<code>random_uniform_initializer</code>，看名字能看出来是一个随机初始化的工具，这也能解释最前面的代码例子。所以，真的是文档写错了吗。glorot怎么看也不像是一个单词啊。</p>
<p>文档里还有一个说明的，这个函数会将加变量空间作为前缀，而且执行<code>reuse</code>检查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>):</div><div class="line">    v = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])  <span class="comment"># v.name == "foo/v:0"</span></div><div class="line">    w = tf.get_variable(<span class="string">"w"</span>, [<span class="number">1</span>])  <span class="comment"># w.name == "foo/w:0"</span></div><div class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>, reuse=<span class="keyword">True</span>):</div><div class="line">    v1 = tf.get_variable(<span class="string">"v"</span>)  <span class="comment"># The same as v above.</span></div></pre></td></tr></table></figure>
<p>网上的一篇博文：<a href="http://blog.csdn.net/u012436149/article/details/53696970" target="_blank" rel="external">http://blog.csdn.net/u012436149/article/details/53696970</a></p>
<blockquote>
<ol>
<li>使用<code>tf.Variable</code>时，如果检测到命名冲突，系统会自己处理。使用<code>tf.get_variable()</code>时，系统不会处理冲突，而会报错</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line">w_1 = tf.get_variable(name=<span class="string">"w_1"</span>,initializer=<span class="number">1</span>)</div><div class="line">w_2 = tf.get_variable(name=<span class="string">"w_1"</span>,initializer=<span class="number">2</span>)</div><div class="line"><span class="comment">#错误信息</span></div><div class="line"><span class="comment">#ValueError: Variable w_1 already exists, disallowed. Did</span></div><div class="line"><span class="comment">#you mean to set reuse=True in VarScope?</span></div></pre></td></tr></table></figure>
<hr>
<p>下面看<code>tf.Variable</code>类</p>
<blockquote>
<p>一个变量通过调用<code>run()</code>来在图中维持状态。你在图中增加爱一个变来那个，通过构建一个<code>Variable</code>类的实例。</p>
<p><code>Variable()</code>构造器需要一个变量的初始值，可以是一个任何类型和shape的<code>Tensor</code>。构造之后，类型和shape都固定了。值可以通过<code>assign</code>方法改变。</p>
</blockquote>
<p>使用<code>Tensor</code>的操作，也可以使用<code>Variable</code>。</p>
<p>当有一个图之后，可以通过变量的<code>initializer</code>操作来初始化它。</p>
<p>最常见的初始化方法是使用<code>global_variables_initializer()</code>初始化所有的变量。</p>
<p>如果你需要创建一个变量，这个变量的值依赖于应该一个变量，使用另外那个变量的<code>initialized_value()</code>。这保证让你的变量以正确的顺序初始化。</p>
<p><code>global_variables()</code>返回图中所有变量的集合。</p>
<p>初始化方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">__init__(initial_value=<span class="keyword">None</span>,</div><div class="line">         trainable=<span class="keyword">True</span>, </div><div class="line">         collections=<span class="keyword">None</span>, </div><div class="line">         validate_shape=<span class="keyword">True</span>, </div><div class="line">         caching_device=<span class="keyword">None</span>, </div><div class="line">         name=<span class="keyword">None</span>, </div><div class="line">         variable_def=<span class="keyword">None</span>, </div><div class="line">         dtype=<span class="keyword">None</span>, </div><div class="line">         expected_shape=<span class="keyword">None</span>,</div><div class="line">         import_scope=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/Usage-of-ThreadPool/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/Usage-of-ThreadPool/" itemprop="url">
                  《Java并发编程实战》读书笔记——线程池的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-03T20:15:35+08:00">
                2017-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="任务与执行策略之间的隐形耦合"><a href="#任务与执行策略之间的隐形耦合" class="headerlink" title="任务与执行策略之间的隐形耦合"></a>任务与执行策略之间的隐形耦合</h3><p>Executor可以将生产者和消费者解耦，但是不是所有的任务<em>都适用所有的执行策略</em>，有些类型的任务需要<em>明确地指定执行策略</em>。</p>
<ol>
<li><strong>依赖性任务</strong>: 如果一个任务是独立的，改变线程池的大小和配置只会影响性能。如果需要以来其他的任务，那么必须小心的维持这些执行策略以避免产生<em>活跃性</em>问题。</li>
<li><strong>使用线程封闭机制的任务</strong>：单线程的Executor能对并发性做出更强的承诺。如果将Executor从单线程环境改为线程池环境，那么将会失去线程安全性。</li>
<li><strong>对相应时间敏感的task</strong>：比如说GUI处理用户操作的task。</li>
<li><strong>使用了ThreadLocal类的task</strong>：只有当线程本地值的生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义。ThreadLocal让每个线程都拥有某个变量的私有版本与线程池重用线程相矛盾。</li>
</ol>
<p>只有当任务都是同类型，并且相互独立时，线程池的性能才能达到最佳。</p>
<ul>
<li>如果运行时间较长和较短的任务混合在一起，可能造成“拥塞”</li>
<li>如果任务依赖于其他任务，可能造成“死锁”</li>
</ul>
<h4 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h4><p>所有正在执行的任务都由于等待其他人处于工作队列中的任务而阻塞，这种现象被称为线程饥饿死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDeadlock</span></span>&#123;</div><div class="line">  <span class="comment">//这里的newSingleThreadExecutor()方法返回的线程池只包含单个线程</span></div><div class="line">  ExecutorService exec = Executors.newSingleThreadExecutor();</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderPageTask</span> <span class="title">implement</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Execptioin</span>&#123;</div><div class="line">      Future&lt;String&gt; header, footer;</div><div class="line">      headr = exec.submit(<span class="keyword">new</span> loadFileTask(<span class="string">"header.html"</span>));</div><div class="line">      footer = exec.submit(<span class="keyword">new</span> loadFileTask(<span class="string">"footer.html"</span>));</div><div class="line">      String page = renderBody();</div><div class="line">      <span class="comment">//这里的get将会死锁。</span></div><div class="line">      <span class="keyword">return</span> header.get()+page+footer.get();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了显式的限制，还有一些情况也会发生死锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarvationDeadLock</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);  </div><div class="line">        <span class="comment">// 设定await在Barrier对象上的线程数达到4个时, 其await方法才释放  </span></div><div class="line">        <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">// 重复提交4个task, 每个task都await在barrier对象上  </span></div><div class="line">        <span class="comment">// barrier的await方法将一直阻塞, 直到4个线程都到达await点.  </span></div><div class="line">        <span class="comment">// 但是线程池中只有3个线程, 不可能出现4个线程都达到await点的情形, 所以依然会发生死锁  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;  </div><div class="line">            executor.submit(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">                <span class="meta">@Override</span>  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        System.out.println(<span class="string">"waiting for other tasks arriving at common point"</span>);  </div><div class="line">                        barrier.await();  </div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                        Thread.currentThread().interrupt();  </div><div class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="运行时长较长的任务"><a href="#运行时长较长的任务" class="headerlink" title="运行时长较长的任务"></a>运行时长较长的任务</h4><p>线程池中线程的数量应该多于稳定状态下执行较长时长任务的数量。</p>
<p>限定任务等待资源的时间：平台类库中的大多数可阻塞方法中，都同时定义了限时版本和无限时版本，例如<code>Thread.join</code>,<code>BlockingQueue.put</code>.<code>CountDownLatch.await</code>,<code>Selector.select</code>等。如果等待超时，可以把任务标识为失败，终止或者重新放回队列。</p>
<h3 id="设置线程池的大小"><a href="#设置线程池的大小" class="headerlink" title="设置线程池的大小"></a>设置线程池的大小</h3><ul>
<li>计算环境：cpu</li>
<li>资源预算：内存</li>
<li>任务的特性：计算密集型还是IO密集型，是否需要JDBC连接这样的稀缺资源。</li>
</ul>
<p>如果需要执行不同类别并且行为相差较大的任务，可以考虑使用多个线程池。</p>
<p>对于计算密集型task, 合适的size大约为CPU数量+1.</p>
<p>IO密集型task，size = CPU数量 <em> CPU利用率 </em> (1 + 等待时间和计算时间的比例)。</p>
<p>内存等：每个任务对该资源的需求量除资源总量，就是线程池大小的上限。</p>
<h3 id="配置ThradPoolExecutor"><a href="#配置ThradPoolExecutor" class="headerlink" title="配置ThradPoolExecutor"></a>配置ThradPoolExecutor</h3><p>ThreadPoolExecutor通用构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></div><div class="line">                         //线程的基本大小，没有任务执行时的大小。</div><div class="line">                         <span class="keyword">int</span> corePoolSize,</div><div class="line">                         <span class="keyword">int</span> maximumPoolSize,//最大大小</div><div class="line">						 //存活时间，超过标记为可回收。</div><div class="line">                         <span class="keyword">long</span> keepAliveTime,</div><div class="line">                         TimeUnit unit,</div><div class="line">                         BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                         ThreadFactory threadFactory,</div><div class="line">                         RejectedExecutionHandler handler)&#123;……&#125;</div></pre></td></tr></table></figure>
<h4 id="线程的创建和销毁"><a href="#线程的创建和销毁" class="headerlink" title="线程的创建和销毁"></a>线程的创建和销毁</h4><ul>
<li>newCachedThreadPool 最大大小设定为<code>Integer.Max_Value</code>，基本大小为0，超时为1分钟</li>
<li>newFixedThreadPool  基本大小和最大大小设定为指定的值，而且创建的线程池不会超时</li>
<li>newScheduledThreadExecutor 核心线程数由调用方指定, 最大线程数为Integer.MAX_VALUE, 超时时间为0  </li>
</ul>
<h4 id="管理队列任务"><a href="#管理队列任务" class="headerlink" title="管理队列任务"></a>管理队列任务</h4><ul>
<li><strong>无界队列</strong>：newFixedThreadPoll和newSingleThreadExecutor在默认情况下将使用一个无界的<code>LinkedBlockingQueue</code>。</li>
<li><strong>有界队列</strong>：<code>ArrayBlockingQueue</code>，有界的<code>LinkedBlockingQueue</code> <code>PriorityBlockingQueue</code>。在队列填满后，使用饱和策略解决。队列的大小必须和线程池的大小一起调节，如果线程池小队列大，会限制吞吐量。</li>
<li><strong>同步移交</strong>（Synchronous Handoff）： 对于非常大或者无界的线程池，使用<code>SynchronousQueue</code>来避免任务排队，直接将任务从生产者移交给消费者线程。线程池无界或者可以拒绝任务时，<code>SynchronousQWueue</code>才有实际价值，在<code>newCachedThreadPool</code>工厂方法就使用了<code>SynchronousQueue</code>。</li>
</ul>
<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>在有界队列填满之后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略通过<code>setRejectedExecutionHandler</code>来修改。</p>
<ul>
<li>Abort Policy：抛出未检查的<code>RejectedExecutioniException</code>，调用者可以捕获这个异常，然后根据需求编写处理代码。</li>
<li>Caller-Runs Policy：将某些任务回退到调用者，从而降低新任务的流量。在提交task的线程中执行task，从而提交task的线程就不能提交task，当这一层的请求队列被填满后，再向上蔓延，一直达到客户端，实现一种平缓的性能降低。</li>
<li>Discard policy：抛弃该任务</li>
<li>Discard Oldest Policy：抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果使用优先队列，那么将抛弃优先级最高的）</li>
</ul>
<h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThreadFactory</span><span class="params">(String poolName)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.poolName = poolName;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyAppThread(runnable, pollName);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String poolName;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThreadFactory</span><span class="params">(String poolName)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.poolName = poolName;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyAppThread(runnable, poolName);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"MyAppThread"</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> debugLifecycle = <span class="keyword">false</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger created = <span class="keyword">new</span> AtomicInteger();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger alive = <span class="keyword">new</span> AtomicInteger();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = Logger.getAnonymousLogger();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyAppThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>(r, DEFAULT_NAME);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyAppThread</span><span class="params">(Runnable runnable, String name)</span> </span>&#123;</div><div class="line">		<span class="comment">// 为自定义的Thread类指定线程名称</span></div><div class="line">		<span class="keyword">super</span>(runnable, name + <span class="string">"-"</span> + created.incrementAndGet());</div><div class="line">		<span class="comment">// 设置UncaughtExceptionHandler. UncaughtExceptionHandler的uncaughtException方法将在线程运行中抛出未捕获异常时由系统调用</span></div><div class="line">		setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</div><div class="line">				log.log(Level.SEVERE, <span class="string">"UNCAUGHT in thread "</span> + t.getName(), e);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 复制debug标志以确保一致的值。。。？ </span></div><div class="line">		<span class="keyword">boolean</span> debug = debugLifecycle;</div><div class="line">		<span class="keyword">if</span> (debug)</div><div class="line">			log.log(Level.FINE, <span class="string">"Created "</span> + getName());</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			alive.incrementAndGet();</div><div class="line">			<span class="keyword">super</span>.run();</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			alive.decrementAndGet();</div><div class="line">			<span class="keyword">if</span> (debug)</div><div class="line">				log.log(Level.FINE, <span class="string">"Exiting "</span> + getName());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsCreated</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> created.get();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsAlive</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> alive.get();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDebug</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> debugLifecycle;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</div><div class="line">		debugLifecycle = b;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="在调用构造函数后再设置ThreadPoolExecutor"><a href="#在调用构造函数后再设置ThreadPoolExecutor" class="headerlink" title="在调用构造函数后再设置ThreadPoolExecutor"></a>在调用构造函数后再设置ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line"><span class="keyword">if</span>(exec <span class="keyword">instanceof</span> ThreadPoolExecutor)</div><div class="line">  ((ThreadPoolExecutor)exec).setCorePoolSize(<span class="number">10</span>);</div><div class="line"><span class="keyword">else</span></div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Error"</span>);</div></pre></td></tr></table></figure>
<h3 id="扩展ThreadPoolExecutor"><a href="#扩展ThreadPoolExecutor" class="headerlink" title="扩展ThreadPoolExecutor"></a>扩展ThreadPoolExecutor</h3><p>ThreadPoolExecutor类提供了多个”钩子”方法, 以供其子类实现, 比如<code>beforeExecute</code>, <code>afterExecute</code>, <code>terminated</code>等. 所谓”钩子”是指基类预留的, 但是没有提供具体实现的方法, 其方法体为空. 子类可以根据需要为”钩子”提供具体实现。</p>
<p><code>beforeExecute</code>和<code>afterExecute</code>方法分别在执行task前后调用<code>beforeExecute</code>和<code>afterExecute</code>方法可以用于记录日志, 统计数据等操作。</p>
<p><code>terminated</code>方法在线程池被关闭后调用。 <code>terminated</code>方法可以用于释放线程池申请的资源。</p>
<h3 id="递归算法的并行化"><a href="#递归算法的并行化" class="headerlink" title="递归算法的并行化"></a>递归算法的并行化</h3><p>如果<strong>循环</strong>中的迭代操作都是独立的，并且不需要等待所有的迭代操作都完成再继续执行，那么可以使用Executor将穿行循环转化为并行循环。</p>
<p>如果需要提交一个任务集，并等待他们完成，那么可以使用<code>ExecutorService.invokeAll</code>，并且在所有任务都执行完成后调用<code>CompletionService</code>来获取结果。</p>
<p>在递归中并行：将在节点上的计算与递归访问分开，将计算并行化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">parallelRecursive</span><span class="params">(<span class="keyword">final</span> Executor exec,</span></span></div><div class="line">                                 List&lt;Node&lt;T&gt;&gt; nodes,</div><div class="line">                                 <span class="keyword">final</span> Collection&lt;t&gt; results)&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">final</span> Node&lt;T&gt; n : nodes)&#123;</div><div class="line">      exec.execute(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">          results.add(n.compute());</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">      parallelRecursive(exec, n.getChildren(),results);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用sutdown和awaitTermination等方法等待所有的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>&lt;T&gt; Collection&lt;T&gt; <span class="title">getParallelResults</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes)</span></span></div><div class="line">  <span class="keyword">throws</span> InterruptedExeception&#123;</div><div class="line">  ExectorService exec = Executors.newCachedThreadPool();</div><div class="line">  Queue&lt;T&gt; resultQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;T&gt;;</div><div class="line">  parallelRecursive(exec, nodes, resultQueue);</div><div class="line">  exec.shutdown();</div><div class="line">  exec.awaitTermination(Long.MAX_VALUE,TimeUnit.SECONDS);</div><div class="line">  <span class="keyword">return</span> resultQueue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>shutdown</code>方法：平滑的关闭<code>ExecutorService</code>，当此方法被调用时，<code>ExecutorService</code>停止接收新的任务并且等待已经提交的任务（包含提交正在执行和提交未执行）执行完成。当所有提交任务执行完毕，线程池即被关闭。</li>
<li><code>awaitTermination</code>方法：接收人<code>timeout和</code> <code>TimeUnit</code>两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测<code>ExecutorService</code>是否已经关闭，若关闭则返回true，否则返回false。一般情况下会和<code>shutdown</code>方法组合使用。</li>
</ul>
<p><strong>P151的示例待看</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/TensorFlow-touorials-rnn/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/TensorFlow-touorials-rnn/" itemprop="url">
                  TensorFlow-touorials-rnn
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-24T23:12:22+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><p>在这个教程中，我们将会展示如何在一个具有挑战的语言模型上训练循环神经网络。这个问题的目的是为了拟合一个给句子分配概率的概率模型。它通过根据前面的历史单词预测下一个单词来坐到这一点。为此，我们使用<a href="https://catalog.ldc.upenn.edu/ldc99t42" target="_blank" rel="external">Penn Tree Bank</a>数据集，该数据集是衡量这个模型质量的基准，同时小巧方便训练。</p>
<p>语言模型时很多有趣问题的关键，比如说语音识别、机器翻译、图片字幕。参考<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="external">这里</a>。</p>
<p>为了达到目的，我们将重现<a href="http://arxiv.org/abs/1409.2329" target="_blank" rel="external">Zaremba et al., 2014</a>（<a href="http://arxiv.org/pdf/1409.2329.pdf" target="_blank" rel="external">pdf</a>）中的结果，他们在PTB数据集上取得了很好的效果。</p>
<h3 id="教程文件"><a href="#教程文件" class="headerlink" title="教程文件"></a>教程文件</h3><p>这个教程依赖<a href="https://github.com/tensorflow/models" target="_blank" rel="external">TensorFlow models repo</a>中<code>models/tutorials/rnn/ptb</code>下的文件：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ptb_word_lm.py</td>
<td>在PTB数据集上训练语言模型的代码</td>
</tr>
<tr>
<td>reader.py</td>
<td>读取数据集的代码</td>
</tr>
</tbody>
</table>
<h3 id="下载以及准备数据"><a href="#下载以及准备数据" class="headerlink" title="下载以及准备数据"></a>下载以及准备数据</h3><p>这个教程需要的数据在PTB数据集的<code>data/</code>文件夹里面，来自Toms Mikolov’s的页面：<a href="http://www.fit.vutbr.cz/~imikolov/rnnlm/simple-examples.tgz" target="_blank" rel="external">http://www.fit.vutbr.cz/~imikolov/rnnlm/simple-examples.tgz</a></p>
<p>这个数据集已经预处理并包含了超过10000个不同的单词，包括句尾标记符号和稀有单词的特殊字符。在<code>reader.py</code>中，我们将每个单词转换为一个唯一的整数标记，为了让他在神经网络中处理起来更容易。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p>模型的核心包括一次处理一个单词的LSTM单元，并计算句子中下一个单词的可能值的概率。网络中的存储状态被初始化为零向量，在读取每一个单词后更新。为了计算，我们将以<code>batch_size</code>的小批进行处理。</p>
<p>伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size)</div><div class="line"><span class="comment"># Initial state of the LSTM memory.</span></div><div class="line">state = tf.zeros([batch_size, lstm.state_size])</div><div class="line">probabilities = []</div><div class="line">loss = <span class="number">0.0</span></div><div class="line"><span class="keyword">for</span> current_batch_of_words <span class="keyword">in</span> words_in_dataset:</div><div class="line">    <span class="comment"># The value of state is updated after processing each batch of words.</span></div><div class="line">    output, state = lstm(current_batch_of_words, state)</div><div class="line"></div><div class="line">    <span class="comment"># The LSTM output can be used to make next word predictions</span></div><div class="line">    logits = tf.matmul(output, softmax_w) + softmax_b</div><div class="line">    probabilities.append(tf.nn.softmax(logits))</div><div class="line">    loss += loss_function(probabilities, target_words)</div></pre></td></tr></table></figure>
<h4 id="截断反向传播"><a href="#截断反向传播" class="headerlink" title="截断反向传播"></a><em>截断反向传播</em></h4><p>依据设计，RNN的输出取决于不同的输入。不幸的是，这让反向传播算法计算困难。为了让学习过程易于控制，通常创建一个“unrolled”版本的网络，其包含了固定数量（num_steps）的LSTM输入和输出。然后对RNN进行有限的近似运算。这可以通过一次喂长度为<code>num_steps</code>的输入，在每次这样输入后执行反向过程来实现。</p>
<p>这是一个同于创建执行截断反向传播的图的简略代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Placeholder for the inputs in a given iteration.</span></div><div class="line">words = tf.placeholder(tf.int32, [batch_size, num_steps])</div><div class="line"></div><div class="line">lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size)</div><div class="line"><span class="comment"># Initial state of the LSTM memory.</span></div><div class="line">initial_state = state = tf.zeros([batch_size, lstm.state_size])</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_steps):</div><div class="line">    <span class="comment"># The value of state is updated after processing each batch of words.</span></div><div class="line">    output, state = lstm(words[:, i], state)</div><div class="line"></div><div class="line">    <span class="comment"># The rest of the code.</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">final_state = state</div></pre></td></tr></table></figure>
<p>如何实现在整个数据集上面的迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A numpy array holding the state of LSTM after each batch of words.</span></div><div class="line">numpy_state = initial_state.eval()</div><div class="line">total_loss = <span class="number">0.0</span></div><div class="line"><span class="keyword">for</span> current_batch_of_words <span class="keyword">in</span> words_in_dataset:</div><div class="line">    numpy_state, current_loss = session.run([final_state, loss],</div><div class="line">        <span class="comment"># Initialize the LSTM state from the previous iteration.</span></div><div class="line">        feed_dict=&#123;initial_state: numpy_state, words: current_batch_of_words&#125;)</div><div class="line">    total_loss += current_loss</div></pre></td></tr></table></figure>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>词汇ID会被嵌入到密度表示，在喂给LSTM之前。这允许模型有效的表示某一单词的知识。实现起来也很简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># embedding_matrix is a tensor of shape [vocabulary_size, embedding size]</span></div><div class="line">word_embeddings = tf.nn.embedding_lookup(embedding_matrix, word_ids)</div></pre></td></tr></table></figure>
<p>这个嵌入矩阵将会被随机初始化，模型将会学习区分这些单词的意义通过观察数据。</p>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>我们想最小化目标词汇的平均负log概率。</p>
<p>$\text{loss} = -\frac{1}{N}\sum<em>{i=1}^{N} \ln p</em>{\text{target}_i}$</p>
<p>实现并不困难，但是函数<code>sequence_loss_by_example</code>已经被提供，所以我们直接在这里使用就可以。</p>
<p>论文中提到的的典型方法是平均每个词的复杂度：</p>
<p>$e^{-\frac{1}{N}\sum<em>{i=1}^{N} \ln p</em>{\text{target}_i}} = e^{\text{loss}}$</p>
<p>我们会在训练过程中见识这一个值。</p>
<h4 id="叠加多个LSTM"><a href="#叠加多个LSTM" class="headerlink" title="叠加多个LSTM"></a>叠加多个LSTM</h4><p>提供的模型很强大，我们可以增加LSTM层数去处理数据。第一层的输出将变成第二层的输入。</p>
<p>我们有一个叫做<code>MultiRNNCell</code>的类，无缝实现这些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size, state_is_tuple=<span class="keyword">False</span>)</div><div class="line">stacked_lstm = tf.contrib.rnn.MultiRNNCell([lstm] * number_of_layers,</div><div class="line">    state_is_tuple=<span class="keyword">False</span>)</div><div class="line"></div><div class="line">initial_state = state = stacked_lstm.zero_state(batch_size, tf.float32)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_steps):</div><div class="line">    <span class="comment"># The value of state is updated after processing each batch of words.</span></div><div class="line">    output, state = stacked_lstm(words[:, i], state)</div><div class="line"></div><div class="line">    <span class="comment"># The rest of the code.</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">final_state = state</div></pre></td></tr></table></figure>
<h3 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><p>教程代码中支持三种模型，”small”,”medium”和”large”，他们的区别是LSTM的大小，和训练使用的超参数集的大小。</p>
<p>模型越大，结果越好。<code>small</code>模型应该可以达到120以下的复杂度在测试集中，<code>large</code>80以下。可能需要几个小时去训练。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/21/about-final-in-java/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/21/about-final-in-java/" itemprop="url">
                  java中的final关键字
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-21T10:05:23+08:00">
                2017-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h3><p>final修饰的类不能被继承</p>
<p>一个类不能同时用final和abstract修饰。</p>
<h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><p>表示方法不能在子类中被override。</p>
<h3 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><p>final修饰的变量表示只能被赋值一次。</p>
<ul>
<li>当修饰一个原生数据类型时，该生数据类型的值不能发生变化。</li>
<li>当修饰一个引用类型时，表示该引用类型不能再指向其他对象了，但是该引用所指向的对象的内容是可以发生变化的。</li>
</ul>
<p>final修饰一个成员变量（属性）时，必须要<em>显式初始化</em>。</p>
<ul>
<li>一种在变量声明的时候初始化</li>
<li>第二种在类的构造函数中对这个变量赋值</li>
</ul>
<blockquote>
<p>java中的局部变量，需要赋初试值。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          
    
        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Zhuo Jimmy" />
          <p class="site-author-name" itemprop="name">Zhuo Jimmy</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2116491901" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:zhuo_jimmy@yeah.net" target="_blank" title="email">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuo Jimmy</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  



  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


</body>
</html>
