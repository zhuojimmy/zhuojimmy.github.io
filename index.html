<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="jlearning.cn">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="jlearning.cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jlearning.cn">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> jlearning.cn </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jlearning.cn</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/27/java-Integer-Object-Compare/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/27/java-Integer-Object-Compare/" itemprop="url">
                  Java中Integer类的三种初始化方式和在逻辑运算上的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-27T21:15:09+08:00">
                2017-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近两次遇到Integer对象比较的问题，记录一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">		Integer a = <span class="keyword">new</span> Integer(<span class="number">1200</span>);</div><div class="line">		Integer b = <span class="keyword">new</span> Integer(<span class="number">1200</span>);</div><div class="line">		<span class="keyword">int</span> c = <span class="number">1200</span>;</div><div class="line">		<span class="keyword">int</span> d = <span class="number">1200</span>;</div><div class="line">		Integer e = <span class="number">1200</span>;</div><div class="line">		Integer f = <span class="number">1200</span>;</div><div class="line">		</div><div class="line">		Integer g = <span class="number">120</span>;</div><div class="line">		Integer h = <span class="number">120</span>;</div><div class="line">				</div><div class="line">				</div><div class="line">		System.out.println(a==b); <span class="comment">//false</span></div><div class="line">		System.out.println(a.equals(b));  <span class="comment">//true</span></div><div class="line">		</div><div class="line">		System.out.println(c==d);  <span class="comment">//true</span></div><div class="line">		<span class="comment">//System.out.println(c.equals(d));</span></div><div class="line">		</div><div class="line">		System.out.println(a==d);  <span class="comment">//true</span></div><div class="line">		System.out.println(a.equals(d));  <span class="comment">//true</span></div><div class="line">		</div><div class="line">		System.out.println(e==f);  <span class="comment">//false</span></div><div class="line">		System.out.println(e.equals(f));  <span class="comment">//true </span></div><div class="line">		</div><div class="line">		System.out.println(g==h);  <span class="comment">//true</span></div><div class="line">		System.out.println(g.equals(h));  <span class="comment">//true</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>几个知识点：</p>
<ol>
<li><code>==</code> 运算符在比较两个对象时，是在比较两个对象引用。所以<code>a</code>和<code>b</code>是两个对象，第一个是<code>false</code></li>
<li><code>.equals()</code>方法需要在类中重写，以比较类中的值，在<code>Integer</code>类中，很显然比较的就是int类型的值，所以第二个是<code>true</code></li>
<li>使用基本类型时，会在内存中产生重用，所以当两次使用<code>int</code>初始化<code>c</code>和<code>d</code>时，实际上使用的是相同的地址。第三个<code>true</code></li>
<li>使用<code>==</code>比较<code>int</code>和<code>Integer</code>时，会自动拆箱，所以第四是<code>true</code>。第五个也是对的。</li>
<li>比较6和8的不同，这里要知道<code>Integer e = 1200</code>等价于<code>Integer e = Integer.valueOf(1200)</code>，看JDK的源码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">  <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">  <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">  	<span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于-128-127之间的数，会进行缓存，下次再初始化时会从缓存中取，而不是new一个。</p>
<ol>
<li>另外再补充一个，用<code>==</code>比较<code>Integer</code>和<code>new Integer</code>的时候，也不会自动拆箱，所以比较的是两个对象引用，所以是false。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/Atomic-and-nonblocking-synchronized/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/Atomic-and-nonblocking-synchronized/" itemprop="url">
                  Java并发性能提升的关键——原子变量与非阻塞同步机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-15T22:04:23+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从这本书的最开始，就接触到原子变量类——<code>AtomicInteger</code>和<code>AtomicReference</code>用于代替锁来实现对安全性的保障。这就是从Java5.0开始的使用原子变量来提供相比较<code>synchronized</code>机制更好的性能和可伸缩性。除此之外，非阻塞的同步机制也能提供这样的良好体验。</p>
<h3 id="锁的劣势"><a href="#锁的劣势" class="headerlink" title="锁的劣势"></a>锁的劣势</h3><ol>
<li>当线程恢复执行时，必须等待其他线程执行完它们的时间片。在挂起和回复线程过程中存在着很大的开销，通常存在较长时间的中断。如果在类中操作量很小，调度开销和工作开销的比值会非常高。</li>
<li>一个线程在等待锁的时候，不能做任何事情。如果持有锁的进程被延迟执行（缺页错误，调度延迟等），其他需要这个锁的线程都无法执行下去。</li>
<li>如果被阻塞的线程优先级较高，持有锁的线程优先级较低，会产生优先级反转。</li>
<li>如果持有锁的线程被永久的阻塞（死循环，死锁，活锁等），程序永远无法执行下去。</li>
</ol>
<p>所以需要一种支持volatile变量的可见性，又支持原子性的机制。</p>
<h3 id="硬件对并发的支持"><a href="#硬件对并发的支持" class="headerlink" title="硬件对并发的支持"></a>硬件对并发的支持</h3><p>现代的处理器提供了既有volatile的可见性，又有原子性的支持。</p>
<p>早期的处理器支持原子的测试并设置(Test-and-Set)、获取并递增(Fetch-and-Increment)和交换(Swap)指令。现在几乎所有的现代处理器中都包含了<strong>原子读-改-写</strong>的指令。例如比较并交换(Compare-and-Swap)，关联加载/条件存储(Load-Linked/Store-Conditional)。</p>
<h4 id="比较并交换（CAS）"><a href="#比较并交换（CAS）" class="headerlink" title="比较并交换（CAS）"></a>比较并交换（CAS）</h4><p>CAS中包含三个操作数——需要读写的内存位置V、进行比较的值A、拟写入的新值B。V的值等于A时，用B来更新V的值，然后返回V的原有值。</p>
<p>当多个线程同时是哟个CAS更新一个变量时，只有一个线程能更新，其他线程都会失败。失败的线程不会被挂起，而是被告知失败，并可以再次尝试。</p>
<h4 id="非阻塞的计数器"><a href="#非阻塞的计数器" class="headerlink" title="非阻塞的计数器"></a>非阻塞的计数器</h4><p>使用CAS实现，读取旧值，加1，使用CAS来设置这个新值。如果CAS失败，立即重试。不会发生阻塞，但是如果多个线程同时更新，会多次执行重试。</p>
<p>在竞争程度不高时，基于CAS的计数器性能上远远超过基于锁的计数器。CAS的主要缺点是：它将使调用者处理竞争问题（重试、回退、放弃），而在锁中能自动处理竞争问题。（阻塞）</p>
<h3 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h3><ol>
<li>更新原子变量的快速路径（非竞争）不会比获取锁的快速路径慢，而它的慢速路径肯定比锁的慢速路径快，因为不需要挂起或重新调度线程。</li>
<li>在发生竞争的情况下，能提供更高的可伸缩性，因为直接利用了硬件对并发的支持。</li>
</ol>
<h3 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h3><p>在基于锁的算法中可能会发生各种活跃性故障，如果线程在持有锁时由于阻塞IO内存缺页等导致推迟执行，那么很可能所有线程都不能继续执行下去。<strong>如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。</strong></p>
<h4 id="非阻塞的栈"><a href="#非阻塞的栈" class="headerlink" title="非阻塞的栈"></a>非阻塞的栈</h4><p>push方法创建一个新的节点，该节点的next域只想当前的栈顶，然后使用CAS把这个新节点放入栈顶。如果在开始插入节点之前，位于栈顶的节点没有发生变化，那么CAS成功，如果栈顶节点发生了变化，失败，而push方法会根据栈的当前状态来更新节点，并且再次尝试。</p>
<h4 id="非阻塞的链表"><a href="#非阻塞的链表" class="headerlink" title="非阻塞的链表"></a>非阻塞的链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(E item)</span></span>&#123;</div><div class="line">  Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(item,<span class="keyword">null</span>);</div><div class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    Node&lt;E&gt; curTail = tail.get();</div><div class="line">    Node&lt;E&gt; tailNext = curTail.next.get();</div><div class="line">    <span class="keyword">if</span>(curTail == tail.get())&#123;</div><div class="line">      <span class="keyword">if</span>(tailNext!=<span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//队列处于中间状态（添加了尾节点，但是尾结点的指针没有指过去，推进尾结点）</span></div><div class="line">        tail.compareAndSet(curTail,tailNext);</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//处于稳定状态，尝试插入新节点</span></div><div class="line">        <span class="keyword">if</span>(curTail.next.compareAndSer(<span class="keyword">null</span>,newNode))&#123;</div><div class="line">          <span class="comment">//插入操作成功，尝试推进尾结点</span></div><div class="line">          tail.compareAndSer(curTail,newNode);</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/11/outer-sort/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/11/outer-sort/" itemprop="url">
                  《数据结构与算法设计》读书笔记——外部排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-11T20:58:07+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上个月在某养猪场面试，面试官问了一个问题：“如何用256M内存的机器对一个2G的数据进行排序”。之前没看过这方面的内容，想了一下说用<em>归并排序</em>，然后简略的说了一下我的想法。现在再来看书里关于外部排序的内容，只能说当时的大方向没错，但是剩下的具体实现、外部空间复杂度计算、时间复杂度计算和优化等都没考虑到位。</p>
<p>因为计算机的外部访问是非常慢的（相对比从内存读数据），如果使用和“把数据全部读入内存然后排序”相同的算法，再加上外部存储例如磁带是只能顺序访问，那么任何算法都需要$\Omega(N^2)$次外部数据访问，将是非常可怕的耗时。所以需要有专门用于外部排序的算法。</p>
<p>下面首先第一部分介绍基于归并排序的简单算法，然后第二部分在简单算法的基础上让其支持多路归并可以提高效率，第三部分首先在简单算法上应用多相合并，可以节约外部存储的空间，然后扩展到多路归并上，第四部分针对用于归并的顺串进行改造，在特定的情况下可以提高算法效率。</p>
<h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><p>使用归并排序的思想，简单的双路归并需要四盘磁带（就是外部存储）。最初的数据在$T_{a1}$上，内存为M，就是每次可以使用排序算法对M个数据进行排序。</p>
<ol>
<li>依次从$T_{a1}$上读入M数据，进行排序。</li>
<li>然后交替的输出到Tb1和Tb2上。每组排过序的记录叫做一个<em>顺串</em>。</li>
<li>将 Tb1和Tb2的第一个顺串取出来将两者合并（过程参考归并算法），将结果输出到$T_{a1}$上。</li>
<li>继续上一个步骤，交替的输出到Ta1和Ta2上。直到Tb1或Tb2为空。如果剩下一个顺串，拷贝到适当的磁带上。</li>
<li>这样我们在Ta1和Ta2上得到长度为M的顺串，重复上面的过程，知道得到长度为N的顺串。</li>
</ol>
<p>示例：</p>
<p>初始状态：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th>81 94 11 96 12 35 17 99 28 58 41 75 15</th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b2}$</td>
</tr>
</tbody>
</table>
<p>第1，第2步之后：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td>11 81 94</td>
<td>17 28 99</td>
<td>15</td>
</tr>
<tr>
<td>$T_{b2}$</td>
<td>12 35 96</td>
<td>41 58 75</td>
</tr>
</tbody>
</table>
<p>第3，第4步之后：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th>11 12 35 81 94 96</th>
<th>15</th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td>17 28 41 58 75 99</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$T_{b2}$</td>
<td></td>
</tr>
</tbody>
</table>
<p>重复这个从Ta1 Ta2归并到Tb1 Tb2，从Tb1 Tb2归并到Ta1 Ta2的过程：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td>11 12 17 28 35 51 58 75 81 94 96 99</td>
</tr>
<tr>
<td>$T_{b2}$</td>
<td>15</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th>11 12 15 17 28 35 51 58 75 81 94 96 99</th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b2}$</td>
</tr>
</tbody>
</table>
<p>完成！</p>
<p>我们“从Ta1 Ta2归并到Tb1 Tb2，从Tb1 Tb2归并到Ta1 Ta2”这个过程用了3趟。因为第一次顺串的长度为M，在二路归并的情况下，每次将顺串的长度延长一倍，需要$\lceil log_2(N/M)\rceil$趟。</p>
<h3 id="多路合并"><a href="#多路合并" class="headerlink" title="多路合并"></a>多路合并</h3><p>上面的简单算法就是二路合并，我们将其扩展到一般状态——k路合并。</p>
<p>k路合并需要2k盘磁带，每次将顺串的长度扩充为原来的k倍。在合并的时候，在k个元素中发现最小值是比二路合并复杂的地方，可以使用优先队列。多路合并和二路合并区别不大，就不举例子了。k路合并需要的趟数是$\lceil log_k(N/M)\rceil$</p>
<h3 id="多相合并"><a href="#多相合并" class="headerlink" title="多相合并"></a>多相合并</h3><p>在上面的多路合并中，k-路合并需要2k盘磁带。使用多相合并后，只使用2k-1盘磁带也可以达到相同的效果，可以节省外部存储空间。下面看如何用三盘磁带完成2-路合并：</p>
<ol>
<li>$T_1$上有34个顺串长度的数据，可以选择排序后在$T_2$$T_3$上分别输出17个顺串。</li>
<li>合并输出到$T _1$上，$T_1$上有17个顺串。</li>
<li>将8个顺串从$T_1$拷贝到$T_2$上，然后合并到$T_3$上，这时候$T_3$有9个顺串。</li>
<li>每次拷贝二分之一个顺串到一个空的磁带上，然后合并到剩下的那个空的磁带上。</li>
</ol>
<p>可以优化一下，让每次合并完成之后天然形成两个磁带有顺串，一个为空的情景：</p>
<ol>
<li>把$T_1$上的数据排序后，把21个顺串放到$T_2$上面，13个放到$T_3$上。</li>
<li>合并之后，$T_3$为空，$T_1$上有13个顺串，$T_2$上有8个顺串。</li>
<li>合并，$T_2$空，$T_3$上有8个顺串，$T_1$上有5个。重复这个过程。</li>
</ol>
<p>第一步分配的策略是：如果总顺串的数量是斐波那契数$F_N$,那么将顺串分解成F(N-1)和 F(N-2)。如果不是斐波那契数，需要用一些<em>哑顺串</em>(dummy run)来填补磁带。</p>
<p>将上面三盘磁带完成2-路合并扩展到k-路的多相合并，顺串分解使用k阶斐波那契数列：</p>
<p>$$F^{(k)}(N)=F^{(k)}(N-1)+F^{(k)}(N-2)+……+F^{(k)}(N-k)$$</p>
<p>$$F^{(k)}(N)=0,0\le k-2$$</p>
<p>$$F^{(k)}(k-1)=1$$</p>
<p>5阶斐波那契数列就是：</p>
<p>0，0，0，0，1，1，2，4，8，16，31，61……</p>
<h3 id="替换选择"><a href="#替换选择" class="headerlink" title="替换选择"></a>替换选择</h3><p>上面的排序算法中，第一步顺串的生成都使用了常规内存排序的方法，每次可以生成和内存容量一样大的有序数列。在<em>替换选择</em>算法中，无序数列平均可以生成2M长度的顺串。</p>
<ol>
<li>M个数据被读入内存，并放到一个优先队列中。执行一次DeleteMin把最小记录输出到磁带上。</li>
<li>内存空出一个位置，在从磁带读入下一个记录，如果比刚刚输出的数据要大，放入优先队列。否则把这个新元素存入优先队列的<em>死区</em>(dead space)。</li>
<li>重复上一个步骤，知道优先队列的大小为0，结束第一个顺串的构造。</li>
<li>使用死区中的所有元素建立一个新的优先队列，重复1，2，3的过程。</li>
</ol>
<p>替换选择在一些情况下，如果说大部分的数都是逆序的，效果并不比表标准算法好。但是，如果输入数据是大致顺序的，那么可以第一步就产生很长的顺串，减少来回归并的趟数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/11/structuring-your-TensorFlow-Model/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/11/structuring-your-TensorFlow-Model/" itemprop="url">
                  如何重构TensorFlow模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-11T20:56:34+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="构建你的TensorFlow模型"><a href="#构建你的TensorFlow模型" class="headerlink" title="构建你的TensorFlow模型"></a>构建你的TensorFlow模型</h2><p>翻译自：<a href="http://danijar.com/structuring-your-tensorflow-models/" target="_blank" rel="external">http://danijar.com/structuring-your-tensorflow-models/</a></p>
<p>Defining your models in TensorFlow can easily result in one huge wall of code. How to structure your code in a readable and reusable way? For the inpacient of you, here is the link to a <a href="https://gist.github.com/danijar/8663d3bbfd586bffecf6a0094cd116f2" target="_blank" rel="external">working example gist</a>.</p>
<p>第一句话不会翻译”wall of code”，算了，这不重要。</p>
<h3 id="定义计算图-Compute-Graph"><a href="#定义计算图-Compute-Graph" class="headerlink" title="定义计算图(Compute Graph)"></a>定义计算图(Compute Graph)</h3><p>每个模型使用一个类作为开始是非常明智的。类的接口是什么？通常，你的模型连接一些输入数据和目标<code>placeholders</code>，并且提供训练、测试的操作和接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, target)</span>:</span></div><div class="line">        data_size = int(data.get_shape()[<span class="number">1</span>])</div><div class="line">        target_size = int(target.get_shape()[<span class="number">1</span>])</div><div class="line">        <span class="comment">#truncated_normal返回正态分布的随机值</span></div><div class="line">        weight = tf.Variable(tf.truncated_normal([data_size, target_size]))</div><div class="line">        bias = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[target_size]))</div><div class="line">        incoming = tf.matmul(data, weight) + bias</div><div class="line">        self._prediction = tf.nn.softmax(incoming)</div><div class="line">        <span class="comment">#计算交叉熵，reduce_sum还能这样用？和文档写的不一样啊。</span></div><div class="line">        cross_entropy = -tf.reduce_sum(target, tf.log(self._prediction))</div><div class="line">        <span class="comment">#使用RMSPropOptimizer以0.03为learning rate最小化交叉熵</span></div><div class="line">        self._optimize = tf.train.RMSPropOptimizer(<span class="number">0.03</span>).minimize(cross_entropy)</div><div class="line">        mistakes = tf.not_equal(</div><div class="line">            tf.argmax(target, <span class="number">1</span>), tf.argmax(self._prediction, <span class="number">1</span>))</div><div class="line">        <span class="comment">#求平均误差</span></div><div class="line">        self._error = tf.reduce_mean(tf.cast(mistakes, tf.float32))</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prediction</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._prediction</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._optimize</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._error</div></pre></td></tr></table></figure>
<p>这基本上是在TensorFlow中定义模型的基础代码。但是他有一些问题。最值得注意的是，这个图在单个函数（构造函数）中定义，非常不具备可读性和可重用性。</p>
<h3 id="使用属性"><a href="#使用属性" class="headerlink" title="使用属性"></a>使用属性</h3><p>仅仅将代码分割在函数中是不行的，因为每次函数被调用的时候，图都会被新的代码扩展。因此，我们需要确保这些操作只有在函数第一次调用的时候才添加到图里面。这就是基本的惰性加载。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, target)</span>:</span></div><div class="line">        self.data = data</div><div class="line">        self.target = target</div><div class="line">        self._prediction = <span class="keyword">None</span></div><div class="line">        self._optimize = <span class="keyword">None</span></div><div class="line">        self._error = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prediction</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._prediction:</div><div class="line">            data_size = int(self.data.get_shape()[<span class="number">1</span>])</div><div class="line">            target_size = int(self.target.get_shape()[<span class="number">1</span>])</div><div class="line">            weight = tf.Variable(tf.truncated_normal([data_size, target_size]))</div><div class="line">            bias = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[target_size]))</div><div class="line">            incoming = tf.matmul(self.data, weight) + bias</div><div class="line">            self._prediction = tf.nn.softmax(incoming)</div><div class="line">        <span class="keyword">return</span> self._prediction</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._optimize:</div><div class="line">            cross_entropy = -tf.reduce_sum(self.target, tf.log(self.prediction))</div><div class="line">            optimizer = tf.train.RMSPropOptimizer(<span class="number">0.03</span>)</div><div class="line">            self._optimize = optimizer.minimize(cross_entropy)</div><div class="line">        <span class="keyword">return</span> self._optimize</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._error:</div><div class="line">            mistakes = tf.not_equal(</div><div class="line">                tf.argmax(self.target, <span class="number">1</span>), tf.argmax(self.prediction, <span class="number">1</span>))</div><div class="line">            self._error = tf.reduce_mean(tf.cast(mistakes, tf.float32))</div><div class="line">        <span class="keyword">return</span> self._error</div></pre></td></tr></table></figure>
<p> 这比第一个例子中的代码好多了。你的代码现在被构建在函数中，你现在可以分别关注他们。但是，由于延迟加载逻辑，代码仍然有一些臃肿。下面让我们改正它。</p>
<h3 id="惰性属性装饰器"><a href="#惰性属性装饰器" class="headerlink" title="惰性属性装饰器"></a>惰性属性装饰器</h3><p>python是一个相当灵活的语言。现在让我想你展示如何剔除上一段代码中的冗余代码。我们将使用一个行为就像<code>@property</code>一样的装饰器，但是只执行函数一次。他会在被装饰的函数后面将结果储存在一个命名成员中，而且后面的调用中返回结果。如果你还没有用过自定义装饰器，你可能需要看一下这个<a href="http://blog.apcelent.com/python-decorator-tutorial-with-example.html" target="_blank" rel="external">教程</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_property</span><span class="params">(function)</span>:</span></div><div class="line">    attribute = <span class="string">'_cache_'</span> + function.__name__</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line"><span class="meta">    @functools.wraps(function)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, attribute):</div><div class="line">            setattr(self, attribute, function(self))</div><div class="line">        <span class="keyword">return</span> getattr(self, attribute)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p>使用这个装饰器后，我们的例子简化成为下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, target)</span>:</span></div><div class="line">        self.data = data</div><div class="line">        self.target = target</div><div class="line">        self.prediction</div><div class="line">        self.optimize</div><div class="line">        self.error</div><div class="line"></div><div class="line"><span class="meta">    @lazy_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prediction</span><span class="params">(self)</span>:</span></div><div class="line">        data_size = int(self.data.get_shape()[<span class="number">1</span>])</div><div class="line">        target_size = int(self.target.get_shape()[<span class="number">1</span>])</div><div class="line">        weight = tf.Variable(tf.truncated_normal([data_size, target_size]))</div><div class="line">        bias = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[target_size]))</div><div class="line">        incoming = tf.matmul(self.data, weight) + bias</div><div class="line">        <span class="keyword">return</span> tf.nn.softmax(incoming)</div><div class="line"></div><div class="line"><span class="meta">    @lazy_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(self)</span>:</span></div><div class="line">        cross_entropy = -tf.reduce_sum(self.target, tf.log(self.prediction))</div><div class="line">        optimizer = tf.train.RMSPropOptimizer(<span class="number">0.03</span>)</div><div class="line">        <span class="keyword">return</span> optimizer.minimize(cross_entropy)</div><div class="line"></div><div class="line"><span class="meta">    @lazy_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></div><div class="line">        mistakes = tf.not_equal(</div><div class="line">            tf.argmax(self.target, <span class="number">1</span>), tf.argmax(self.prediction, <span class="number">1</span>))</div><div class="line">        <span class="keyword">return</span> tf.reduce_mean(tf.cast(mistakes, tf.float32))</div></pre></td></tr></table></figure>
<p>注意，我们提到构造函数中的属性。这样可以确保完整的图在我们执行<code>tf.initialize_variables()</code>时被定义。</p>
<h3 id="通过命名空间组织图"><a href="#通过命名空间组织图" class="headerlink" title="通过命名空间组织图"></a>通过命名空间组织图</h3><p>我们现在已经有一个清晰的方式去定义我们的模型，但是导致计算图非常拥挤。如果你想对图进行可视化，他将会有用很多互联的小节点。现在要在每个函数外面包裹<code>tf.name_scope(&#39;name&#39;)</code>或者<code>tf.varizble_scope(&#39;name&#39;)</code>。节点将会在图中分组。我们可以调整我们前面的装饰器去自动实现这些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">define_scope</span><span class="params">(function)</span>:</span></div><div class="line">    attribute = <span class="string">'_cache_'</span> + function.__name__</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line"><span class="meta">    @functools.wraps(function)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, attribute):</div><div class="line">            <span class="keyword">with</span> tf.variable_scope(function.__name):</div><div class="line">                setattr(self, attribute, function(self))</div><div class="line">        <span class="keyword">return</span> getattr(self, attribute)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p>我给这个装饰器一个新的名字（define_scope），因为除了添加惰性缓存之外他还有针对RensorFlow的特定功能。除此之外，这个模型看上去和前一个一样。</p>
<p>我们可以进一步的允许<code>@define_scope</code>装饰器forward arguments to the <code>tf.variable_scope()</code>，例如定义一个命名空间内的默认的初始化器(initializer)。可以参考作者上传的完整版代码：<a href="https://gist.github.com/danijar/8663d3bbfd586bffecf6a0094cd116f2" target="_blank" rel="external">https://gist.github.com/danijar/8663d3bbfd586bffecf6a0094cd116f2</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/05/avoid-deadlock/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/05/avoid-deadlock/" itemprop="url">
                  《Java并发编程实战》读书笔记——避免活跃性问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-05T16:45:17+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了让并发程序安全，会选择加锁。但是过度、不恰当的加锁会导致“锁顺序死锁”。同样，使用线程池和信号量来限制对资源的使用，这些被限制的行为可能导致“资源死锁”。这一章会主要介绍死锁的分类，主要根据死锁产生的原因进行分类。和如何避免和诊断死锁。最后介绍死锁之外的其他活跃性风险，比如说饥饿等。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>一个资源每次只能被一个人使用（互斥条件），每个人都拥有其他人需要的资源，同时又等待其他人已经拥有的资源（请求与保持条件），并且在每个人在获得所有需要的资源之前都不放弃已经拥有的资源（不剥夺条件）。（循环等待）就产生了死锁。</p>
<h4 id="锁顺序死锁"><a href="#锁顺序死锁" class="headerlink" title="锁顺序死锁"></a>锁顺序死锁</h4><p>两个线程试图用不同的顺序来获得相同的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadLock</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(left)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(right)&#123;</div><div class="line">        doSomething();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(right)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(left)&#123;</div><div class="line">        doSomethind();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要想验证锁顺序的一致性，需要对程序中的加锁行为进行全局分析。</p>
<h4 id="动态的锁顺序死锁"><a href="#动态的锁顺序死锁" class="headerlink" title="动态的锁顺序死锁"></a>动态的锁顺序死锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount, Account toAccount, DollarAmount amount)</span></span></div><div class="line">  <span class="keyword">throws</span> InsufficientFundsException&#123;</div><div class="line">    <span class="keyword">synchronized</span>(fromAccount)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(toAccount)&#123;</div><div class="line">        <span class="keyword">if</span>(fromAccount.getBalance().comparaTo(amount)&lt;<span class="number">0</span>)</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">          fromAccount.debit(amount);</div><div class="line">          toAccount.credit(amount);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>虽然锁顺序都是先取得<code>fromAccount</code>的锁，在取得<code>toAccount</code>的锁，但是事实上上锁的顺序取决于传递给函数的参数的顺序。</p>
<p>这种死锁可以通过制定锁的顺序来解决。使用<code>System.identityHashCode</code>方法，每次先获得<code>hashCode</code>小的那个对象的锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object tieLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMonet</span><span class="params">(<span class="keyword">final</span> Account fromAcct,<span class="keyword">final</span> Account toAcct, <span class="keyword">final</span> DollarAmount amount)</span> <span class="keyword">throws</span> insufficientFundsException</span>&#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Helper</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> <span class="keyword">throws</span> InsufficientFundsException</span>&#123;</div><div class="line">      <span class="keyword">if</span>(fromAcct.getBalance().comparaTo(amount)&lt;<span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> insufficientFundsException();</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        fromAcct.debit(amount);</div><div class="line">        toAcct.credit(amount);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">int</span> fromHash = System.identityHashCode(fromAcct);</div><div class="line">  <span class="keyword">int</span> toHash = System.identityHashCode(toAcct);</div><div class="line">  </div><div class="line">  <span class="keyword">if</span>(fromHash&lt;toHash)&#123;</div><div class="line">    <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">        <span class="keyword">new</span> Helper().transfer();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(from Hash&gt;toHash)&#123;</div><div class="line">    <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">        <span class="keyword">new</span> Helper().transfer();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//极少数的情况下，两个对象拥有相同的散列值，此时通过另一个锁保证每次只有一个线程以位置的顺序获得这两个锁。如果经常出先散列冲突的情况，这个地方因为相当于给整个程序加一个锁，会成为性能瓶颈。</span></div><div class="line">    <span class="keyword">synchronized</span>(tieLock)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">        <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">          <span class="keyword">new</span> Helper().transfer();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果每个账户都包含唯一不可变的可比的键值，会更简单，不用比较散列值。</p>
<h4 id="在协作对象之间发生的死锁"><a href="#在协作对象之间发生的死锁" class="headerlink" title="在协作对象之间发生的死锁"></a>在协作对象之间发生的死锁</h4><p>在持有锁的情况下调用某个外部方法，这个外部方法中可能会获取其他锁。可能会像锁顺序死锁一样。</p>
<h4 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h4><p>如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。</p>
<p>使用同步代码块仅被用于保护那些设计共享状态的操作。</p>
<h4 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h4><p>如果某些任务需要等待其他任务的结果，妈么这些任务往往是产生线程饥饿死锁的主要来源。</p>
<h3 id="死锁的避免与诊断"><a href="#死锁的避免与诊断" class="headerlink" title="死锁的避免与诊断"></a>死锁的避免与诊断</h3><p>如果程序每次最多只获得一个锁，那么就不会发生死锁。但是不现实。所以应该在设计时考虑锁的顺序，尽量减少潜在的加锁交互数量。</p>
<p>两阶段策略（Two-Part Strategy）：</p>
<ul>
<li>找出在什么地方将获取多个锁。</li>
<li>多所有这些实例进行全局分析，确保他们在整个程序中获取锁的顺序都是一致的。</li>
</ul>
<h4 id="支持定时的锁"><a href="#支持定时的锁" class="headerlink" title="支持定时的锁"></a>支持定时的锁</h4><p>显式使用Lock类中的定时tryLock功能来代替内置锁机制。显式锁可以指定一个超时时限，等待超过该事件后会返回一个失败信息。</p>
<h4 id="通过线程转储（Thread-Dump）信息来分析死锁"><a href="#通过线程转储（Thread-Dump）信息来分析死锁" class="headerlink" title="通过线程转储（Thread Dump）信息来分析死锁"></a>通过线程转储（Thread Dump）信息来分析死锁</h4><h3 id="其他活跃性问题"><a href="#其他活跃性问题" class="headerlink" title="其他活跃性问题"></a>其他活跃性问题</h3><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>当前线程由于无法访问它需要的资源而不能继续执行，就发生了饥饿。最典型的是由于错误的使用线程优先级，导致获取不到CPU时钟周期。</p>
<h4 id="糟糕的响应性"><a href="#糟糕的响应性" class="headerlink" title="糟糕的响应性"></a>糟糕的响应性</h4><p>CPU密集型后台任务与事件线程竞争CPU的时钟周期，从而影响响应性。</p>
<p>可以通过降低后台任务的优先级解决这个问题。</p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>错误的将不可修复的错误作为可修复的错误，导致如果不能成功处理某个消息，那么就回滚并重新放到队列开头，反复调用返回相同的结果。</p>
<p>当多个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行。就发生了活锁。</p>
<p>需要在重试机制中引入随机性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/04/difference-between-tf-Variable-and-tf-get-variable/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/04/difference-between-tf-Variable-and-tf-get-variable/" itemprop="url">
                  TensorFlow——tf.Variable和tf.get_variable()的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-04T16:18:43+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基础用法的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var1 = tf.get_variable(<span class="string">"var3"</span>,[<span class="number">1</span>])</div><div class="line">sess.run(tf.global_variables_initializer())</div><div class="line">var1.eval()</div><div class="line"><span class="comment">#输出：array([-1.57205701], dtype=float32)</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">W = tf.Variable([<span class="number">.3</span>], tf.float32)</div><div class="line">b = tf.Variable([<span class="number">-.3</span>], tf.float32)</div><div class="line">x = tf.placeholder(tf.float32)</div><div class="line">linear_model = W * x + b</div><div class="line">init = tf.global_variables_initializer()</div><div class="line">sess.run(init)</div><div class="line">print(sess.run(linear_model, &#123;x:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;))</div><div class="line"><span class="comment">#输出 [ 0.          0.30000001  0.60000002  0.90000004]</span></div></pre></td></tr></table></figure>
<p>看看文档怎么说：</p>
<blockquote>
<p>tf.get_variable:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; get_variable(</div><div class="line">&gt;     name,</div><div class="line">&gt;     shape=<span class="keyword">None</span>,</div><div class="line">&gt;     <span class="comment">#变来那个类型，默认DT_FLOAT</span></div><div class="line">&gt;     dtype=<span class="keyword">None</span>,</div><div class="line">&gt;     initializer=<span class="keyword">None</span>,</div><div class="line">&gt;     regularizer=<span class="keyword">None</span>,</div><div class="line">&gt;     trainable=<span class="keyword">True</span>,</div><div class="line">&gt;     collections=<span class="keyword">None</span>,</div><div class="line">&gt;     caching_device=<span class="keyword">None</span>,</div><div class="line">&gt;     partitioner=<span class="keyword">None</span>,</div><div class="line">&gt;     validate_shape=<span class="keyword">True</span>,</div><div class="line">&gt;     use_resource=<span class="keyword">None</span>,</div><div class="line">&gt;     custom_getter=<span class="keyword">None</span></div><div class="line">&gt; )</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>通过参数得到一个已经存在的变量，或者创建一个新的变量。</p>
<p>如果<code>initializer</code>是<code>None</code>，将会应用变来那个空间(variable scope)的默认<code>initilizer</code>。如果这个也是<code>None</code>，将会应用<code>glorot_uniform_initializer</code>。<code>initializer</code>也可以是一个<code>Tensor</code>，在这种情况下，变来那个将会被初始化为这个值和这个<code>shape</code>。</p>
</blockquote>
<p>所以，<code>glorot_uniform_initializer</code>是什么？在文档里搜了一下，搜不到。最接近的是<code>random_uniform_initializer</code>，看名字能看出来是一个随机初始化的工具，这也能解释最前面的代码例子。所以，真的是文档写错了吗。glorot怎么看也不像是一个单词啊。</p>
<p>文档里还有一个说明的，这个函数会将加变量空间作为前缀，而且执行<code>reuse</code>检查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>):</div><div class="line">    v = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])  <span class="comment"># v.name == "foo/v:0"</span></div><div class="line">    w = tf.get_variable(<span class="string">"w"</span>, [<span class="number">1</span>])  <span class="comment"># w.name == "foo/w:0"</span></div><div class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>, reuse=<span class="keyword">True</span>):</div><div class="line">    v1 = tf.get_variable(<span class="string">"v"</span>)  <span class="comment"># The same as v above.</span></div></pre></td></tr></table></figure>
<p>网上的一篇博文：<a href="http://blog.csdn.net/u012436149/article/details/53696970" target="_blank" rel="external">http://blog.csdn.net/u012436149/article/details/53696970</a></p>
<blockquote>
<ol>
<li>使用<code>tf.Variable</code>时，如果检测到命名冲突，系统会自己处理。使用<code>tf.get_variable()</code>时，系统不会处理冲突，而会报错</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line">w_1 = tf.get_variable(name=<span class="string">"w_1"</span>,initializer=<span class="number">1</span>)</div><div class="line">w_2 = tf.get_variable(name=<span class="string">"w_1"</span>,initializer=<span class="number">2</span>)</div><div class="line"><span class="comment">#错误信息</span></div><div class="line"><span class="comment">#ValueError: Variable w_1 already exists, disallowed. Did</span></div><div class="line"><span class="comment">#you mean to set reuse=True in VarScope?</span></div></pre></td></tr></table></figure>
<hr>
<p>下面看<code>tf.Variable</code>类</p>
<blockquote>
<p>一个变量通过调用<code>run()</code>来在图中维持状态。你在图中增加爱一个变来那个，通过构建一个<code>Variable</code>类的实例。</p>
<p><code>Variable()</code>构造器需要一个变量的初始值，可以是一个任何类型和shape的<code>Tensor</code>。构造之后，类型和shape都固定了。值可以通过<code>assign</code>方法改变。</p>
</blockquote>
<p>使用<code>Tensor</code>的操作，也可以使用<code>Variable</code>。</p>
<p>当有一个图之后，可以通过变量的<code>initializer</code>操作来初始化它。</p>
<p>最常见的初始化方法是使用<code>global_variables_initializer()</code>初始化所有的变量。</p>
<p>如果你需要创建一个变量，这个变量的值依赖于应该一个变量，使用另外那个变量的<code>initialized_value()</code>。这保证让你的变量以正确的顺序初始化。</p>
<p><code>global_variables()</code>返回图中所有变量的集合。</p>
<p>初始化方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">__init__(initial_value=<span class="keyword">None</span>,</div><div class="line">         trainable=<span class="keyword">True</span>, </div><div class="line">         collections=<span class="keyword">None</span>, </div><div class="line">         validate_shape=<span class="keyword">True</span>, </div><div class="line">         caching_device=<span class="keyword">None</span>, </div><div class="line">         name=<span class="keyword">None</span>, </div><div class="line">         variable_def=<span class="keyword">None</span>, </div><div class="line">         dtype=<span class="keyword">None</span>, </div><div class="line">         expected_shape=<span class="keyword">None</span>,</div><div class="line">         import_scope=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/Usage-of-ThreadPool/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/Usage-of-ThreadPool/" itemprop="url">
                  《Java并发编程实战》读书笔记——线程池的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-03T20:15:35+08:00">
                2017-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="任务与执行策略之间的隐形耦合"><a href="#任务与执行策略之间的隐形耦合" class="headerlink" title="任务与执行策略之间的隐形耦合"></a>任务与执行策略之间的隐形耦合</h3><p>Executor可以将生产者和消费者解耦，但是不是所有的任务<em>都适用所有的执行策略</em>，有些类型的任务需要<em>明确地指定执行策略</em>。</p>
<ol>
<li><strong>依赖性任务</strong>: 如果一个任务是独立的，改变线程池的大小和配置只会影响性能。如果需要以来其他的任务，那么必须小心的维持这些执行策略以避免产生<em>活跃性</em>问题。</li>
<li><strong>使用线程封闭机制的任务</strong>：单线程的Executor能对并发性做出更强的承诺。如果将Executor从单线程环境改为线程池环境，那么将会失去线程安全性。</li>
<li><strong>对相应时间敏感的task</strong>：比如说GUI处理用户操作的task。</li>
<li><strong>使用了ThreadLocal类的task</strong>：只有当线程本地值的生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义。ThreadLocal让每个线程都拥有某个变量的私有版本与线程池重用线程相矛盾。</li>
</ol>
<p>只有当任务都是同类型，并且相互独立时，线程池的性能才能达到最佳。</p>
<ul>
<li>如果运行时间较长和较短的任务混合在一起，可能造成“拥塞”</li>
<li>如果任务依赖于其他任务，可能造成“死锁”</li>
</ul>
<h4 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h4><p>所有正在执行的任务都由于等待其他人处于工作队列中的任务而阻塞，这种现象被称为线程饥饿死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDeadlock</span></span>&#123;</div><div class="line">  <span class="comment">//这里的newSingleThreadExecutor()方法返回的线程池只包含单个线程</span></div><div class="line">  ExecutorService exec = Executors.newSingleThreadExecutor();</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderPageTask</span> <span class="title">implement</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Execptioin</span>&#123;</div><div class="line">      Future&lt;String&gt; header, footer;</div><div class="line">      headr = exec.submit(<span class="keyword">new</span> loadFileTask(<span class="string">"header.html"</span>));</div><div class="line">      footer = exec.submit(<span class="keyword">new</span> loadFileTask(<span class="string">"footer.html"</span>));</div><div class="line">      String page = renderBody();</div><div class="line">      <span class="comment">//这里的get将会死锁。</span></div><div class="line">      <span class="keyword">return</span> header.get()+page+footer.get();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了显式的限制，还有一些情况也会发生死锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarvationDeadLock</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);  </div><div class="line">        <span class="comment">// 设定await在Barrier对象上的线程数达到4个时, 其await方法才释放  </span></div><div class="line">        <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">// 重复提交4个task, 每个task都await在barrier对象上  </span></div><div class="line">        <span class="comment">// barrier的await方法将一直阻塞, 直到4个线程都到达await点.  </span></div><div class="line">        <span class="comment">// 但是线程池中只有3个线程, 不可能出现4个线程都达到await点的情形, 所以依然会发生死锁  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;  </div><div class="line">            executor.submit(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">                <span class="meta">@Override</span>  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        System.out.println(<span class="string">"waiting for other tasks arriving at common point"</span>);  </div><div class="line">                        barrier.await();  </div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                        Thread.currentThread().interrupt();  </div><div class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="运行时长较长的任务"><a href="#运行时长较长的任务" class="headerlink" title="运行时长较长的任务"></a>运行时长较长的任务</h4><p>线程池中线程的数量应该多于稳定状态下执行较长时长任务的数量。</p>
<p>限定任务等待资源的时间：平台类库中的大多数可阻塞方法中，都同时定义了限时版本和无限时版本，例如<code>Thread.join</code>,<code>BlockingQueue.put</code>.<code>CountDownLatch.await</code>,<code>Selector.select</code>等。如果等待超时，可以把任务标识为失败，终止或者重新放回队列。</p>
<h3 id="设置线程池的大小"><a href="#设置线程池的大小" class="headerlink" title="设置线程池的大小"></a>设置线程池的大小</h3><ul>
<li>计算环境：cpu</li>
<li>资源预算：内存</li>
<li>任务的特性：计算密集型还是IO密集型，是否需要JDBC连接这样的稀缺资源。</li>
</ul>
<p>如果需要执行不同类别并且行为相差较大的任务，可以考虑使用多个线程池。</p>
<p>对于计算密集型task, 合适的size大约为CPU数量+1.</p>
<p>IO密集型task，size = CPU数量 <em> CPU利用率 </em> (1 + 等待时间和计算时间的比例)。</p>
<p>内存等：每个任务对该资源的需求量除资源总量，就是线程池大小的上限。</p>
<h3 id="配置ThradPoolExecutor"><a href="#配置ThradPoolExecutor" class="headerlink" title="配置ThradPoolExecutor"></a>配置ThradPoolExecutor</h3><p>ThreadPoolExecutor通用构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></div><div class="line">                         //线程的基本大小，没有任务执行时的大小。</div><div class="line">                         <span class="keyword">int</span> corePoolSize,</div><div class="line">                         <span class="keyword">int</span> maximumPoolSize,//最大大小</div><div class="line">						 //存活时间，超过标记为可回收。</div><div class="line">                         <span class="keyword">long</span> keepAliveTime,</div><div class="line">                         TimeUnit unit,</div><div class="line">                         BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                         ThreadFactory threadFactory,</div><div class="line">                         RejectedExecutionHandler handler)&#123;……&#125;</div></pre></td></tr></table></figure>
<h4 id="线程的创建和销毁"><a href="#线程的创建和销毁" class="headerlink" title="线程的创建和销毁"></a>线程的创建和销毁</h4><ul>
<li>newCachedThreadPool 最大大小设定为<code>Integer.Max_Value</code>，基本大小为0，超时为1分钟</li>
<li>newFixedThreadPool  基本大小和最大大小设定为指定的值，而且创建的线程池不会超时</li>
<li>newScheduledThreadExecutor 核心线程数由调用方指定, 最大线程数为Integer.MAX_VALUE, 超时时间为0  </li>
</ul>
<h4 id="管理队列任务"><a href="#管理队列任务" class="headerlink" title="管理队列任务"></a>管理队列任务</h4><ul>
<li><strong>无界队列</strong>：newFixedThreadPoll和newSingleThreadExecutor在默认情况下将使用一个无界的<code>LinkedBlockingQueue</code>。</li>
<li><strong>有界队列</strong>：<code>ArrayBlockingQueue</code>，有界的<code>LinkedBlockingQueue</code> <code>PriorityBlockingQueue</code>。在队列填满后，使用饱和策略解决。队列的大小必须和线程池的大小一起调节，如果线程池小队列大，会限制吞吐量。</li>
<li><strong>同步移交</strong>（Synchronous Handoff）： 对于非常大或者无界的线程池，使用<code>SynchronousQueue</code>来避免任务排队，直接将任务从生产者移交给消费者线程。线程池无界或者可以拒绝任务时，<code>SynchronousQWueue</code>才有实际价值，在<code>newCachedThreadPool</code>工厂方法就使用了<code>SynchronousQueue</code>。</li>
</ul>
<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>在有界队列填满之后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略通过<code>setRejectedExecutionHandler</code>来修改。</p>
<ul>
<li>Abort Policy：抛出未检查的<code>RejectedExecutioniException</code>，调用者可以捕获这个异常，然后根据需求编写处理代码。</li>
<li>Caller-Runs Policy：将某些任务回退到调用者，从而降低新任务的流量。在提交task的线程中执行task，从而提交task的线程就不能提交task，当这一层的请求队列被填满后，再向上蔓延，一直达到客户端，实现一种平缓的性能降低。</li>
<li>Discard policy：抛弃该任务</li>
<li>Discard Oldest Policy：抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果使用优先队列，那么将抛弃优先级最高的）</li>
</ul>
<h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThreadFactory</span><span class="params">(String poolName)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.poolName = poolName;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyAppThread(runnable, pollName);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String poolName;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThreadFactory</span><span class="params">(String poolName)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.poolName = poolName;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyAppThread(runnable, poolName);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"MyAppThread"</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> debugLifecycle = <span class="keyword">false</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger created = <span class="keyword">new</span> AtomicInteger();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger alive = <span class="keyword">new</span> AtomicInteger();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = Logger.getAnonymousLogger();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyAppThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>(r, DEFAULT_NAME);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyAppThread</span><span class="params">(Runnable runnable, String name)</span> </span>&#123;</div><div class="line">		<span class="comment">// 为自定义的Thread类指定线程名称</span></div><div class="line">		<span class="keyword">super</span>(runnable, name + <span class="string">"-"</span> + created.incrementAndGet());</div><div class="line">		<span class="comment">// 设置UncaughtExceptionHandler. UncaughtExceptionHandler的uncaughtException方法将在线程运行中抛出未捕获异常时由系统调用</span></div><div class="line">		setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</div><div class="line">				log.log(Level.SEVERE, <span class="string">"UNCAUGHT in thread "</span> + t.getName(), e);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 复制debug标志以确保一致的值。。。？ </span></div><div class="line">		<span class="keyword">boolean</span> debug = debugLifecycle;</div><div class="line">		<span class="keyword">if</span> (debug)</div><div class="line">			log.log(Level.FINE, <span class="string">"Created "</span> + getName());</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			alive.incrementAndGet();</div><div class="line">			<span class="keyword">super</span>.run();</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			alive.decrementAndGet();</div><div class="line">			<span class="keyword">if</span> (debug)</div><div class="line">				log.log(Level.FINE, <span class="string">"Exiting "</span> + getName());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsCreated</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> created.get();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsAlive</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> alive.get();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDebug</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> debugLifecycle;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</div><div class="line">		debugLifecycle = b;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="在调用构造函数后再设置ThreadPoolExecutor"><a href="#在调用构造函数后再设置ThreadPoolExecutor" class="headerlink" title="在调用构造函数后再设置ThreadPoolExecutor"></a>在调用构造函数后再设置ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line"><span class="keyword">if</span>(exec <span class="keyword">instanceof</span> ThreadPoolExecutor)</div><div class="line">  ((ThreadPoolExecutor)exec).setCorePoolSize(<span class="number">10</span>);</div><div class="line"><span class="keyword">else</span></div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Error"</span>);</div></pre></td></tr></table></figure>
<h3 id="扩展ThreadPoolExecutor"><a href="#扩展ThreadPoolExecutor" class="headerlink" title="扩展ThreadPoolExecutor"></a>扩展ThreadPoolExecutor</h3><p>ThreadPoolExecutor类提供了多个”钩子”方法, 以供其子类实现, 比如<code>beforeExecute</code>, <code>afterExecute</code>, <code>terminated</code>等. 所谓”钩子”是指基类预留的, 但是没有提供具体实现的方法, 其方法体为空. 子类可以根据需要为”钩子”提供具体实现。</p>
<p><code>beforeExecute</code>和<code>afterExecute</code>方法分别在执行task前后调用<code>beforeExecute</code>和<code>afterExecute</code>方法可以用于记录日志, 统计数据等操作。</p>
<p><code>terminated</code>方法在线程池被关闭后调用。 <code>terminated</code>方法可以用于释放线程池申请的资源。</p>
<h3 id="递归算法的并行化"><a href="#递归算法的并行化" class="headerlink" title="递归算法的并行化"></a>递归算法的并行化</h3><p>如果<strong>循环</strong>中的迭代操作都是独立的，并且不需要等待所有的迭代操作都完成再继续执行，那么可以使用Executor将穿行循环转化为并行循环。</p>
<p>如果需要提交一个任务集，并等待他们完成，那么可以使用<code>ExecutorService.invokeAll</code>，并且在所有任务都执行完成后调用<code>CompletionService</code>来获取结果。</p>
<p>在递归中并行：将在节点上的计算与递归访问分开，将计算并行化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">parallelRecursive</span><span class="params">(<span class="keyword">final</span> Executor exec,</span></span></div><div class="line">                                 List&lt;Node&lt;T&gt;&gt; nodes,</div><div class="line">                                 <span class="keyword">final</span> Collection&lt;t&gt; results)&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">final</span> Node&lt;T&gt; n : nodes)&#123;</div><div class="line">      exec.execute(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">          results.add(n.compute());</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">      parallelRecursive(exec, n.getChildren(),results);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用sutdown和awaitTermination等方法等待所有的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>&lt;T&gt; Collection&lt;T&gt; <span class="title">getParallelResults</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes)</span></span></div><div class="line">  <span class="keyword">throws</span> InterruptedExeception&#123;</div><div class="line">  ExectorService exec = Executors.newCachedThreadPool();</div><div class="line">  Queue&lt;T&gt; resultQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;T&gt;;</div><div class="line">  parallelRecursive(exec, nodes, resultQueue);</div><div class="line">  exec.shutdown();</div><div class="line">  exec.awaitTermination(Long.MAX_VALUE,TimeUnit.SECONDS);</div><div class="line">  <span class="keyword">return</span> resultQueue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>shutdown</code>方法：平滑的关闭<code>ExecutorService</code>，当此方法被调用时，<code>ExecutorService</code>停止接收新的任务并且等待已经提交的任务（包含提交正在执行和提交未执行）执行完成。当所有提交任务执行完毕，线程池即被关闭。</li>
<li><code>awaitTermination</code>方法：接收人<code>timeout和</code> <code>TimeUnit</code>两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测<code>ExecutorService</code>是否已经关闭，若关闭则返回true，否则返回false。一般情况下会和<code>shutdown</code>方法组合使用。</li>
</ul>
<p><strong>P151的示例待看</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/TensorFlow-touorials-rnn/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/TensorFlow-touorials-rnn/" itemprop="url">
                  TensorFlow-touorials-rnn
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-24T23:12:22+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><p>在这个教程中，我们将会展示如何在一个具有挑战的语言模型上训练循环神经网络。这个问题的目的是为了拟合一个给句子分配概率的概率模型。它通过根据前面的历史单词预测下一个单词来坐到这一点。为此，我们使用<a href="https://catalog.ldc.upenn.edu/ldc99t42" target="_blank" rel="external">Penn Tree Bank</a>数据集，该数据集是衡量这个模型质量的基准，同时小巧方便训练。</p>
<p>语言模型时很多有趣问题的关键，比如说语音识别、机器翻译、图片字幕。参考<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="external">这里</a>。</p>
<p>为了达到目的，我们将重现<a href="http://arxiv.org/abs/1409.2329" target="_blank" rel="external">Zaremba et al., 2014</a>（<a href="http://arxiv.org/pdf/1409.2329.pdf" target="_blank" rel="external">pdf</a>）中的结果，他们在PTB数据集上取得了很好的效果。</p>
<h3 id="教程文件"><a href="#教程文件" class="headerlink" title="教程文件"></a>教程文件</h3><p>这个教程依赖<a href="https://github.com/tensorflow/models" target="_blank" rel="external">TensorFlow models repo</a>中<code>models/tutorials/rnn/ptb</code>下的文件：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ptb_word_lm.py</td>
<td>在PTB数据集上训练语言模型的代码</td>
</tr>
<tr>
<td>reader.py</td>
<td>读取数据集的代码</td>
</tr>
</tbody>
</table>
<h3 id="下载以及准备数据"><a href="#下载以及准备数据" class="headerlink" title="下载以及准备数据"></a>下载以及准备数据</h3><p>这个教程需要的数据在PTB数据集的<code>data/</code>文件夹里面，来自Toms Mikolov’s的页面：<a href="http://www.fit.vutbr.cz/~imikolov/rnnlm/simple-examples.tgz" target="_blank" rel="external">http://www.fit.vutbr.cz/~imikolov/rnnlm/simple-examples.tgz</a></p>
<p>这个数据集已经预处理并包含了超过10000个不同的单词，包括句尾标记符号和稀有单词的特殊字符。在<code>reader.py</code>中，我们将每个单词转换为一个唯一的整数标记，为了让他在神经网络中处理起来更容易。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p>模型的核心包括一次处理一个单词的LSTM单元，并计算句子中下一个单词的可能值的概率。网络中的存储状态被初始化为零向量，在读取每一个单词后更新。为了计算，我们将以<code>batch_size</code>的小批进行处理。</p>
<p>伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size)</div><div class="line"><span class="comment"># Initial state of the LSTM memory.</span></div><div class="line">state = tf.zeros([batch_size, lstm.state_size])</div><div class="line">probabilities = []</div><div class="line">loss = <span class="number">0.0</span></div><div class="line"><span class="keyword">for</span> current_batch_of_words <span class="keyword">in</span> words_in_dataset:</div><div class="line">    <span class="comment"># The value of state is updated after processing each batch of words.</span></div><div class="line">    output, state = lstm(current_batch_of_words, state)</div><div class="line"></div><div class="line">    <span class="comment"># The LSTM output can be used to make next word predictions</span></div><div class="line">    logits = tf.matmul(output, softmax_w) + softmax_b</div><div class="line">    probabilities.append(tf.nn.softmax(logits))</div><div class="line">    loss += loss_function(probabilities, target_words)</div></pre></td></tr></table></figure>
<h4 id="截断反向传播"><a href="#截断反向传播" class="headerlink" title="截断反向传播"></a><em>截断反向传播</em></h4><p>依据设计，RNN的输出取决于不同的输入。不幸的是，这让反向传播算法计算困难。为了让学习过程易于控制，通常创建一个“unrolled”版本的网络，其包含了固定数量（num_steps）的LSTM输入和输出。然后对RNN进行有限的近似运算。这可以通过一次喂长度为<code>num_steps</code>的输入，在每次这样输入后执行反向过程来实现。</p>
<p>这是一个同于创建执行截断反向传播的图的简略代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Placeholder for the inputs in a given iteration.</span></div><div class="line">words = tf.placeholder(tf.int32, [batch_size, num_steps])</div><div class="line"></div><div class="line">lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size)</div><div class="line"><span class="comment"># Initial state of the LSTM memory.</span></div><div class="line">initial_state = state = tf.zeros([batch_size, lstm.state_size])</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_steps):</div><div class="line">    <span class="comment"># The value of state is updated after processing each batch of words.</span></div><div class="line">    output, state = lstm(words[:, i], state)</div><div class="line"></div><div class="line">    <span class="comment"># The rest of the code.</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">final_state = state</div></pre></td></tr></table></figure>
<p>如何实现在整个数据集上面的迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A numpy array holding the state of LSTM after each batch of words.</span></div><div class="line">numpy_state = initial_state.eval()</div><div class="line">total_loss = <span class="number">0.0</span></div><div class="line"><span class="keyword">for</span> current_batch_of_words <span class="keyword">in</span> words_in_dataset:</div><div class="line">    numpy_state, current_loss = session.run([final_state, loss],</div><div class="line">        <span class="comment"># Initialize the LSTM state from the previous iteration.</span></div><div class="line">        feed_dict=&#123;initial_state: numpy_state, words: current_batch_of_words&#125;)</div><div class="line">    total_loss += current_loss</div></pre></td></tr></table></figure>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>词汇ID会被嵌入到密度表示，在喂给LSTM之前。这允许模型有效的表示某一单词的知识。实现起来也很简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># embedding_matrix is a tensor of shape [vocabulary_size, embedding size]</span></div><div class="line">word_embeddings = tf.nn.embedding_lookup(embedding_matrix, word_ids)</div></pre></td></tr></table></figure>
<p>这个嵌入矩阵将会被随机初始化，模型将会学习区分这些单词的意义通过观察数据。</p>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>我们想最小化目标词汇的平均负log概率。</p>
<p>$\text{loss} = -\frac{1}{N}\sum<em>{i=1}^{N} \ln p</em>{\text{target}_i}$</p>
<p>实现并不困难，但是函数<code>sequence_loss_by_example</code>已经被提供，所以我们直接在这里使用就可以。</p>
<p>论文中提到的的典型方法是平均每个词的复杂度：</p>
<p>$e^{-\frac{1}{N}\sum<em>{i=1}^{N} \ln p</em>{\text{target}_i}} = e^{\text{loss}}$</p>
<p>我们会在训练过程中见识这一个值。</p>
<h4 id="叠加多个LSTM"><a href="#叠加多个LSTM" class="headerlink" title="叠加多个LSTM"></a>叠加多个LSTM</h4><p>提供的模型很强大，我们可以增加LSTM层数去处理数据。第一层的输出将变成第二层的输入。</p>
<p>我们有一个叫做<code>MultiRNNCell</code>的类，无缝实现这些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size, state_is_tuple=<span class="keyword">False</span>)</div><div class="line">stacked_lstm = tf.contrib.rnn.MultiRNNCell([lstm] * number_of_layers,</div><div class="line">    state_is_tuple=<span class="keyword">False</span>)</div><div class="line"></div><div class="line">initial_state = state = stacked_lstm.zero_state(batch_size, tf.float32)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_steps):</div><div class="line">    <span class="comment"># The value of state is updated after processing each batch of words.</span></div><div class="line">    output, state = stacked_lstm(words[:, i], state)</div><div class="line"></div><div class="line">    <span class="comment"># The rest of the code.</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">final_state = state</div></pre></td></tr></table></figure>
<h3 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><p>教程代码中支持三种模型，”small”,”medium”和”large”，他们的区别是LSTM的大小，和训练使用的超参数集的大小。</p>
<p>模型越大，结果越好。<code>small</code>模型应该可以达到120以下的复杂度在测试集中，<code>large</code>80以下。可能需要几个小时去训练。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/21/about-final-in-java/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/21/about-final-in-java/" itemprop="url">
                  java中的final关键字
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-21T10:05:23+08:00">
                2017-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h3><p>final修饰的类不能被继承</p>
<p>一个类不能同时用final和abstract修饰。</p>
<h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><p>表示方法不能在子类中被override。</p>
<h3 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><p>final修饰的变量表示只能被赋值一次。</p>
<ul>
<li>当修饰一个原生数据类型时，该生数据类型的值不能发生变化。</li>
<li>当修饰一个引用类型时，表示该引用类型不能再指向其他对象了，但是该引用所指向的对象的内容是可以发生变化的。</li>
</ul>
<p>final修饰一个成员变量（属性）时，必须要<em>显式初始化</em>。</p>
<ul>
<li>一种在变量声明的时候初始化</li>
<li>第二种在类的构造函数中对这个变量赋值</li>
</ul>
<blockquote>
<p>java中的局部变量，需要赋初试值。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/19/《java并发编程实战》读书笔记（二）——对象的共享/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/《java并发编程实战》读书笔记（二）——对象的共享/" itemprop="url">
                  《java并发编程实战》读书笔记（二）——对象的共享
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-19T11:04:45+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>只要在某个线程中无法检测到重排序情况（即使在其他线程中可以很明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。</p>
<p>主线程首先写入a，然后在没有同步的情况下写入b。那么读线程看到的顺序可能与写入的顺序完全相反。</p>
<p>在没有同步的情况下，编译器、处理器以及运行时都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，相对内存操作的执行顺序进行判断，几乎无法得出正确的结论。</p>
<blockquote>
<p>只要有数据在多个线程之间共享，就使用正确的同步。</p>
</blockquote>
<h4 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h4><h4 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h4><p>最低安全性保证：当线程在没有同步的情况下读取变量时，可能会得到一个失效值，至少这个值是之前某个线程设置的值，而不是一个随机值。</p>
<p>对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位操作。如果读操作和写操作在不同的线程中执行，那么很可能会读到某个值的高32位，和另一个值的低32位。</p>
<p>除非用volatile来声明它们。</p>
<h4 id="加锁与可见性"><a href="#加锁与可见性" class="headerlink" title="加锁与可见性"></a>加锁与可见性</h4><p>内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。</p>
<p>访问某个共享且可变的变量时，要求所有线程都在同一个锁上同步，以确保某个线程程写入该变量的值对于其他变量变量来说，都是可见的。</p>
<blockquote>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
</blockquote>
<h4 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h4><p>用于确保将变量的更新操作通知到其他线程。</p>
<p>当把变量生命为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。</p>
<p>不会被缓存再寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p>
<p>仅当volatile变量能简化代码的实现以及对同步策略的验证时，才使用它们。</p>
<p>加锁可以确保原子性和可见性，volatile只能确保可见性。</p>
<p>满足一下所有条件时，才使用volatile变量：</p>
<ul>
<li>对变量的写入操作不依赖变量当前的值（a++不行），或能确保只有单个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中。</li>
<li>在访问变量时不需要加锁。</li>
</ul>
<h3 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h3><p>发布（Publish）：是对象能够在当前作用域之外的代码中使用。</p>
<p>e.g. 将一个指向该对象的引用保存到其他代码可以访问的地方、在某一个非私有的方法中返回该引用、将引用传递到其他类的方法中。</p>
<p>逸出（Escape）：当某个不应该发布的对象被发布。</p>
<p>外部方法（Alien）：行为并不完全由类来规定的方法。包括其他类中定义的方法以及类中可以被改写的方法。非<code>private</code> <code>final</code></p>
<p>当把一个对象传递给某个外部方法，就相当于发布了这个对象。</p>
<p>使用封装的原因：封装能使对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。</p>
<h4 id="安全的对象构造过程"><a href="#安全的对象构造过程" class="headerlink" title="安全的对象构造过程"></a>安全的对象构造过程</h4><p>不要再构造过程中使<code>this</code>引用逸出。</p>
<blockquote>
<p>一个错误：在构造函数中启动一个线程。</p>
<p>当对象在其构造函数中创建一个线程时，无论是显示创建（通过将它传给构造函数），还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的额线程共享。在对象尚未完全构造之前，新的线程就可以看见他。</p>
</blockquote>
<p>如果想在构造函数中注册一个时间监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span></span>&#123;</div><div class="line">    listener = <span class="keyword">new</span> EventListener()&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</div><div class="line">        doSomething(e);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span></span>&#123;</div><div class="line">    safeListener safe = <span class="keyword">new</span> SafeListener();</div><div class="line">    source.registerListener(safe.listener);</div><div class="line">    <span class="keyword">return</span> safe;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><p>一种避免使用同步的方式就是不共享数据。这种技术被称为线程封闭（Thread Confinement）</p>
<h4 id="Ad-hoc线程封闭"><a href="#Ad-hoc线程封闭" class="headerlink" title="Ad-hoc线程封闭"></a>Ad-hoc线程封闭</h4><p>维护线程封闭性的指责完全由程序来承担。</p>
<p>非常脆弱，尽量少用它。</p>
<h4 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h4><p>是线程封闭的一个特例，在栈封闭中，只能通过局部变量才能访问对象。</p>
<p>局部变量的固有属性之一就是封闭在执行线程中。他们位于执行线程的栈中，其他线程无法访问这个栈。</p>
<blockquote>
<p>局部变量：离开了他的域就访问不到</p>
</blockquote>
<p>在维持对象引用的栈封闭性时，程序员需要多做一些工作以确保被应用的对象不会逸出。</p>
<h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><p>能使线程中的某个值与保存值的对象关联起来。</p>
<p>ThreadLocal提供类get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本。因此，get总是返回由当前执行线程在调用set时设置的最新值。</p>
<p>通常用于防止对单实例变量（Singleton）或全局变量进行共享。</p>
<p>当某个频繁执行的操作需要一个临时对象，又希望避免在每次执行时都重新分配该临时对象。使用ThreadLocal。</p>
<p>这些特定于线程的值保存值唉Thread对象中，当线程终止后，这些值会作为垃圾回收。</p>
<blockquote>
<p>download movie</p>
</blockquote>
<h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>不可变对象一定是线程安全的。</p>
<p>对象不可变的条件：</p>
<ul>
<li>对象创建以后其状态就不能修改</li>
<li>对象的所有域都是final类型</li>
<li>对象是正确创建的（在创建期间，this引用没有逸出）</li>
</ul>
<h4 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h4><p>final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。</p>
<h4 id="使用Volatile类型来发布不可变对象"><a href="#使用Volatile类型来发布不可变对象" class="headerlink" title="使用Volatile类型来发布不可变对象"></a>使用Volatile类型来发布不可变对象</h4><p>对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。</p>
<p>当线程获得了对该对象的引用后，就不必担心另一个线程会修改对象的状态。</p>
<p>通过包含多个状态变量的容器对象来维持不变形条件，并使用一个volatile类型的引用来确保可见性，是的Volatile Cached Factorizer在没有显式的使用锁的情况下仍然是线程安全的。</p>
<h3 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h3><h4 id="不正确的发布：正确的对象被破坏"><a href="#不正确的发布：正确的对象被破坏" class="headerlink" title="不正确的发布：正确的对象被破坏"></a>不正确的发布：正确的对象被破坏</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          
    
        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Zhuo Jimmy" />
          <p class="site-author-name" itemprop="name">Zhuo Jimmy</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">27</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2116491901" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:zhuo_jimmy@yeah.net" target="_blank" title="email">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuo Jimmy</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  



  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


</body>
</html>
