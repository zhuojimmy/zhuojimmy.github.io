<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="jlearning.cn">
<meta property="og:url" content="http://learning.com/index.html">
<meta property="og:site_name" content="jlearning.cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jlearning.cn">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://learning.com/"/>





  <title> jlearning.cn </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f69738a703f95d25fd5649f5b3d51e51";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jlearning.cn</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-file">
          <a href="/file" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-file"></i> <br />
            
            文件
          </a>
        </li>
      
        
        <li class="menu-item menu-item-booklist">
          <a href="/booklist" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            书单
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://learning.com/2017/08/18/java-source-code-arraylist/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/18/java-source-code-arraylist/" itemprop="url">
                  Java源码分析——ArrayList
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-18T15:38:10+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/08/18/java-source-code-arraylist/" class="leancloud_visitors" data-flag-title="Java源码分析——ArrayList">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java源码分析——ArrayList"><a href="#Java源码分析——ArrayList" class="headerlink" title="Java源码分析——ArrayList"></a>Java源码分析——ArrayList</h2><p>之前已经分析了HashMap的源码，知道HashMap的内部数据结构是数组+链表+红黑树。相对于HashMap，ArrayList的内部实现方法和操作都简单的多。之前在看《Thinking In Java》的时候已经知道：ArrayList内部是用数组实现的，所以对于随机查询，效率会很高。但是对于在数组中间插入数据，和删除中间元素时，会导致后续元素的移动。</p>
<p>jkd版本为1.8.0_05</p>
<h3 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>继承了AbstractList抽象类，其中实现了List需要的绝大多数公共方法。实现List, Cloneable, Serializable接口。还有一个RandomAccess接口，这是一个空的接口，代表这个类支持快速随机访问。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用一个指定的初始化容量构造ArrayList</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>();</div><div class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                       initialCapacity);</div><div class="line">  <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">&#125;</div><div class="line"><span class="comment">//初始化一个空数组</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>();</div><div class="line">  <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div><div class="line"><span class="comment">//接受一个Collection类型的参数，转化为数组之后进行复制</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">  elementData = c.toArray();</div><div class="line">  size = elementData.length;</div><div class="line">  <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">  <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">    elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="成员字段"><a href="#成员字段" class="headerlink" title="成员字段"></a>成员字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化的默认容量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"><span class="comment">//共享空数组</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"><span class="comment">//ArrayList中的元素数组</span></div><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div><div class="line"><span class="comment">//ArrayList中含有元素的个数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>这里对“共享空数组” Shared empty array instance 不是很理解。</p>
<h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><h5 id="添加—add"><a href="#添加—add" class="headerlink" title="添加—add()"></a>添加—add()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将特定的元素添加到数组的尾部</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">  <span class="comment">//检查空间大小</span></div><div class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">  elementData[size++] = e;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">  <span class="comment">//如果当前的数据元素是空数组，那么需要的容量和默认容量的最大值作为需要的容量</span></div><div class="line">  <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//检查是否需要扩容</span></div><div class="line">  ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">  modCount++;</div><div class="line"></div><div class="line">  <span class="comment">// overflow-conscious code 如果需要的容量大于当前数组的长度，进行一次扩容</span></div><div class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">    grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">  <span class="comment">// overflow-conscious code</span></div><div class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">  <span class="comment">//扩容1.5倍</span></div><div class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">    newCapacity = minCapacity;</div><div class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">    newCapacity = hugeCapacity(minCapacity);</div><div class="line">  <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">  <span class="comment">//然后将数组元素放到新的数组中</span></div><div class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *插入一个指定的元素到特定的位置。将右边的所有元素向右移动一位</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">  <span class="comment">//针对与添加元素，检查是否越界。</span></div><div class="line">  rangeCheckForAdd(index);</div><div class="line">  <span class="comment">//检查是否需要扩容</span></div><div class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">  <span class="comment">//将index---size的元素，拷贝到index+1---size+1的位置上</span></div><div class="line">  System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,size - index);</div><div class="line">  <span class="comment">//插入数据</span></div><div class="line">  elementData[index] = element;</div><div class="line">  size++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="删除—remove"><a href="#删除—remove" class="headerlink" title="删除—remove()"></a>删除—remove()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除指定位置的元素，将右边的所有元素左移一位。</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">  <span class="comment">//index不能超过size</span></div><div class="line">  rangeCheck(index);</div><div class="line"></div><div class="line">  modCount++;</div><div class="line">  E oldValue = elementData(index);</div><div class="line">  <span class="comment">//需要移动的元素个数</span></div><div class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,numMoved);</div><div class="line">  <span class="comment">//复制之后将size--，然后把最后一位赋值null</span></div><div class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (index &gt;= size)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">//遍历，删除第一个为null的元素</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">      <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">        fastRemove(index);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//遍历，删除第一个和o相等的元素，用equals来判断</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">      <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">        fastRemove(index);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">  modCount++;</div><div class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                     numMoved);</div><div class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://learning.com/2017/08/17/java-source-code-hashmap/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/17/java-source-code-hashmap/" itemprop="url">
                  Java源码分析——HashMap
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-17T21:27:34+08:00">
                2017-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/08/17/java-source-code-hashmap/" class="leancloud_visitors" data-flag-title="Java源码分析——HashMap">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java源码分析——HashMap"><a href="#Java源码分析——HashMap" class="headerlink" title="Java源码分析——HashMap"></a>Java源码分析——HashMap</h2><p>HashMap使用一个的数组来保存不同散列值的key以及相应的value。在jkd1.8中，对于相同hashcode形成的bucket，不再按照唯一的链表存储，而是根据bucket的大小，超过一定限制之后将链表转换为红黑树来存储Map.Entry\<k,v\>。这样，HashMap的内部数据结构就是数组+链表+红黑树。</k,v\></p>
<p>jkd版本为1.8.0_05</p>
<h3 id="类的结构："><a href="#类的结构：" class="headerlink" title="类的结构："></a>类的结构：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>一个不明白的地方：AbstractMap已经实现了Map接口，为什么HashMap还要继承AvstractMap之后实现Map。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>HashMap的构造函数有多种重载的方式，这里只详细说明最重要，最复杂的一种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                       initialCapacity);</div><div class="line">  <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">    initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                       loadFactor);</div><div class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">  <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">  <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一个tableSizeFor()方法，就是取大于cap的最小2的整数幂。实现思路是由”1…..”计算得到”1111111+1”。使用将第一位不断的向后移，然后做“或”运算的方法。Doug Lea大神脑路之奇特，让人佩服。</p>
<h3 id="成员字段"><a href="#成员字段" class="headerlink" title="成员字段"></a>成员字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//HashMap的默认初始容量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"><span class="comment">//HashMap的最大容量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">//默认负载系数</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"><span class="comment">//一个bucket的节点数大于这个数字的时候，使用红黑树来存储</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"><span class="comment">//一个bucket的节点数小于这个数字的时候，使用链表来存储</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"><span class="comment">//红黑树的最小容量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</div><div class="line"><span class="comment">//用来散列的数组</span></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">//键值对的数量</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"><span class="comment">//HashMap的结构修改的次数</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line"><span class="comment">//阈值，下一次分配容量的阈值（capacity*loadFactor）</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"><span class="comment">//负载系数</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
<h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><h4 id="计算哈希值"><a href="#计算哈希值" class="headerlink" title="计算哈希值"></a>计算哈希值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> h;</div><div class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一个无符号右移，当h的值小于16位的时候，h^(h&gt;&gt;&gt;16)与h是相等的。当h高于16位的时候，为了防止key的hashcode值的变化只在开头几位，末尾相同，这样导致在与cap-1做&amp;运算的时候，发生大量的哈希冲突，所以使用一些高位来spread(这里怎么翻译？)一下低位。让其低位变得不同。为什么使用异或运算，因为异或运算非常的快。</p>
<h4 id="在HashMap中增加一个键值对"><a href="#在HashMap中增加一个键值对" class="headerlink" title="在HashMap中增加一个键值对"></a>在HashMap中增加一个键值对</h4><p>大概经历了下面几个过程：</p>
<ol>
<li>处理HashMap为空的情况</li>
<li>进行Hash运算，然后查看数组中相应的位置</li>
<li>如果是空的，说明没有Hash冲突，放在这里就好</li>
<li>如果有值，先判断是不是和第一个值的key相同</li>
<li>然后处理是红黑树的情况</li>
<li>最后处理数组的情况</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*<span class="doctag">@param</span> onlyIfAbsent：如果是true，在有相同key的情况下，不要改变现有的value</div><div class="line">*<span class="doctag">@param</span> evict：如果是false，是在构造函数中调用</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">  <span class="comment">//如果数组是空的，做一次扩容。</span></div><div class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">    <span class="comment">//n是当前数组的容量</span></div><div class="line">    n = (tab = resize()).length;</div><div class="line">  <span class="comment">//p取到当前hash散列到的节点。n是2的整数幂，(n-1)&amp;hash做一次哈希值的截取</span></div><div class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">    <span class="comment">//如果这个节点是空的，说明之前没有相同的哈希值，新建一个节点放在这里。</span></div><div class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//下面处理哈希冲突的情况</span></div><div class="line">    Node&lt;K,V&gt; e; K k;</div><div class="line">    <span class="comment">//如果这个bucket里的第一个节点的key与我们正在添加的key相同。（使用equals做判断，所以推荐重写equals）</span></div><div class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">      <span class="comment">//e就是key相同的节点</span></div><div class="line">      e = p;</div><div class="line">    <span class="comment">//如果这个bucket是一个红黑树</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">      <span class="comment">//用红黑树的方式添加一个节点</span></div><div class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//还剩下的情况就是链表了，遍历这个链表。</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">        <span class="comment">//到了链表的结尾，说明没有key相同的，需要在这里插入一个节点。</span></div><div class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">          <span class="comment">//如果当前bucket的数量超过的查找树阈值，转换为查找树的方式，然后跳出。</span></div><div class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">            treeifyBin(tab, hash);</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果查找到了相同的key，也跳出。已经把e的信息保存下来了。</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        p = e;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//现在说明已经存在了相同的key，要进行value的替换</span></div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">      V oldValue = e.value;</div><div class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">        e.value = value;</div><div class="line">      <span class="comment">//这里的afterNodeAccess应该是钩子方法，方便LinkedHashMap继承HashMap的时候可以调用，起到子类影响父类的效果。</span></div><div class="line">      afterNodeAccess(e);</div><div class="line">      <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ++modCount;</div><div class="line">  <span class="comment">//如果容量超过阈值，进行扩容</span></div><div class="line">  <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">    resize();</div><div class="line">  afterNodeInsertion(evict);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>所谓扩容，就是当键值对的数量超过阈值的时候，让当前数组的的容量扩大为当前的两倍，然后进行一次hash再散列的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">  Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">  <span class="keyword">int</span> oldThr = threshold;</div><div class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">      threshold = Integer.MAX_VALUE;</div><div class="line">      <span class="keyword">return</span> oldTab;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//因为数组的容量总是2的整数幂，所以可以使用左移一位的方式达到乘以二的效果，效率更优。</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//这里处理的情况是旧的容量是0，但是阈值不为零。那么就扩容到阈值。</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">    newCap = oldThr;</div><div class="line">  <span class="comment">//容量是0，阈值也是0，全部使用默认的值。</span></div><div class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//按照上面的逻辑，这里处理的是oldCap==0,oldThr&gt;0的情况，不太理解这里。</span></div><div class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">  &#125;</div><div class="line">  threshold = newThr;</div><div class="line">  <span class="comment">//新建一个新的数组，完成容量扩大成为之前二倍的操作。</span></div><div class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">  table = newTab;</div><div class="line">  <span class="comment">//下面进行把老的数组里面的值放到新的数组里</span></div><div class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">      Node&lt;K,V&gt; e;</div><div class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">        oldTab[j] = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//如果老的数组里，bucket只有一个节点，那么进行重新散列，放到新的位置。</span></div><div class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">        <span class="comment">//如果是一颗红黑树，使用TreeNode中的slit方法，将这棵树分成两个小树。</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">        <span class="comment">//下面处理将一个链表分成两个链表。</span></div><div class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">          Node&lt;K,V&gt; next;</div><div class="line">          <span class="keyword">do</span> &#123;</div><div class="line">            next = e.next;</div><div class="line">            <span class="comment">//oldCap应该是二进制“100000……”的形式，那么做&amp;运算之后，刚好可以得到扩容之后哈希值多出来的那一位。我们根据多出来的那一位是1还是0，选择是放在原来的bucket上，还是放在新的bucket上。</span></div><div class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                loHead = e;</div><div class="line">              <span class="keyword">else</span></div><div class="line">                loTail.next = e;</div><div class="line">              loTail = e;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                hiHead = e;</div><div class="line">              <span class="keyword">else</span></div><div class="line">                hiTail.next = e;</div><div class="line">              hiTail = e;</div><div class="line">            &#125;</div><div class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">          <span class="comment">//把两个链表头放在数组里对应的位置，“低位”放在原处，“高位”放在原处+老容量值</span></div><div class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">            loTail.next = <span class="keyword">null</span>;</div><div class="line">            newTab[j] = loHead;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">            hiTail.next = <span class="keyword">null</span>;</div><div class="line">            newTab[j + oldCap] = hiHead;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>网上一个很好的图，借用一下：</p>
<p><img src="http://img.blog.csdn.net/20170805180104619?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG9naW5fc29uYXRh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这是一次扩容之后将老数组里的内容放到新数组的过程"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://learning.com/2017/08/15/Red-Black-Tree/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/15/Red-Black-Tree/" itemprop="url">
                  《数据结构与算法分析》（3）——红黑树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-15T15:26:28+08:00">
                2017-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/08/15/Red-Black-Tree/" class="leancloud_visitors" data-flag-title="《数据结构与算法分析》（3）——红黑树">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h5 id="红黑树是具有下列着色性质的二叉查找树（AVL树）："><a href="#红黑树是具有下列着色性质的二叉查找树（AVL树）：" class="headerlink" title="红黑树是具有下列着色性质的二叉查找树（AVL树）："></a>红黑树是具有下列着色性质的二叉查找树（AVL树）：</h5><ol>
<li>每一个节点或者着成红色，或者着成黑色。</li>
<li>根是黑色的</li>
<li>如果一个节点是红色，那么它的子节点必须是黑色。</li>
<li>从一个节点到一个NULL指针的每一条路径必须包含相同数目的黑色节点。</li>
</ol>
<p>对红黑树的操作在最坏情形下花费$O(logN)$时间，而且一种<strong>慎重的递归实现</strong>可以相对容易地完成。</p>
<p>在红黑树的插入操作中，通常把新项作为树叶放到树中。如果涂成黑色，肯定违反4。所以必须是红色。如果父节点是红色，违反3。这种情况下必须调整该树来确保条件3满足。</p>
<h3 id="自底向上插入"><a href="#自底向上插入" class="headerlink" title="自底向上插入"></a>自底向上插入</h3><h4 id="父亲是红色节点，兄弟是黑色的情形（NULL节点被认为是黑色的）"><a href="#父亲是红色节点，兄弟是黑色的情形（NULL节点被认为是黑色的）" class="headerlink" title="父亲是红色节点，兄弟是黑色的情形（NULL节点被认为是黑色的）"></a>父亲是红色节点，兄弟是黑色的情形（NULL节点被认为是黑色的）</h4><p><img src="\images\Red-Black-Tree\自底向上插入.png" alt="自底向上插入"></p>
<p>X是新加的树叶，为了一般，考虑的是插入一个子树。</p>
<p>在S是黑色的情况下，GPX有一字型和Z字形两种情况（上图中的左上和左下），旋转之后变为右上和右下。这两种情况下都完成了亮点：</p>
<ul>
<li>子树的根都是黑色的，所以不需要关心曾祖的颜色。不可能出现红红相邻的情况。</li>
<li>通向ABC路径上黑色节点的数目，旋转之后和旋转之前保持不变。</li>
</ul>
<h3 id="自顶向下红黑树"><a href="#自顶向下红黑树" class="headerlink" title="自顶向下红黑树"></a>自顶向下红黑树</h3><p>现在来考虑兄弟节点是红色的情况。</p>
<ul>
<li>在向下地过程中，当我们看到一个节点X有两个红儿子的时候，我们让X成为红的而让它的两个儿子是黑的。</li>
<li>当X的父节点P也是红的时候，这种反转将破坏红黑的法则，可以用上图中的适当旋转。</li>
<li>如果X的父节点P的兄弟也是红的呢，这种可能已经被自顶向下过程中处理过了，所以不可能出现。</li>
</ul>
<p>经验指出，平均红黑树大约和平均AVL树一样神，从而查找时间一般接近最优。</p>
<p>执行插入所需要的开销相对较低，实践中发生的旋转相对较少。</p>
<h3 id="自顶向下删除"><a href="#自顶向下删除" class="headerlink" title="自顶向下删除"></a>自顶向下删除</h3><p>首先将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除：</p>
<ol>
<li>被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</li>
<li>被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</li>
<li>被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况2”进行处理。</li>
</ol>
<p>然后通过“旋转和着色”来修正树，使其成为一颗红黑树</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://learning.com/2017/08/14/algorithm-tree-tutorial/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/14/algorithm-tree-tutorial/" itemprop="url">
                  《数据结构与算法分析》（2）——树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-14T14:47:21+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/08/14/algorithm-tree-tutorial/" class="leancloud_visitors" data-flag-title="《数据结构与算法分析》（2）——树">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li>对于任意节点$n_i$，$n_i$的<strong>深度</strong>为从根到自身的惟一路径的长。</li>
<li>$n_i$的<strong>高</strong>是从$n_i$到一片树叶的最长路径的长。    </li>
</ul>
<h5 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h5><ul>
<li>在数据结构种简历到个个儿子节点的连接会产生太多的空间浪费。</li>
<li>将每个节点的所有儿子都放在树节点的链表中。</li>
<li>每个节点都有一个指针指向<strong>儿子</strong>和<strong>下一个兄弟</strong></li>
</ul>
<h5 id="树的遍历及应用"><a href="#树的遍历及应用" class="headerlink" title="树的遍历及应用"></a>树的遍历及应用</h5><ul>
<li><strong>先序遍历</strong>——打印目录列表</li>
<li><strong>后序遍历</strong>——统计每个文件占用的磁盘空间</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul>
<li>类似双链表，一个节点就是关键字信息加上两个只想其他节点的指针</li>
</ul>
<h5 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h5><ul>
<li><strong>中序遍历</strong></li>
<li>构造过程（把后缀表达式转变成表达式树）：<ul>
<li>一次一个符号读入表达式，如果是<em>操作数</em>就建立一个单节点数并将她的指针推入栈中；如果是<em>操作符</em>从栈中弹出指向两棵树T1和T2的那两个指针并形成一颗新的树，将这颗心书的指针压入栈中。</li>
</ul>
</li>
</ul>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><ul>
<li>二叉树的平均深度是$O(logN)$</li>
</ul>
<h5 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h5><ul>
<li>如果T种的关键字是X，那么就返回T，否则对树T的左子树或右子树进行递归调用。</li>
<li>首先要对是否为空树进行测试，否则就可能在NULL指针上兜圈子。</li>
<li>使得最不可能的情况安排在最后进行</li>
</ul>
<h5 id="最值查找"><a href="#最值查找" class="headerlink" title="最值查找"></a>最值查找</h5><ul>
<li>递归实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">findMin(SearchTree T)&#123;</div><div class="line">    <span class="keyword">if</span>(T==NULL)</div><div class="line">      <span class="keyword">return</span> NULL;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="keyword">if</span>(T.left == NULL)</div><div class="line">        <span class="keyword">return</span> T;</div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> findMin(T.left);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>非递归实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">findMax(SearchTree T)&#123;</div><div class="line">    <span class="keyword">if</span>(T!=NULL)</div><div class="line">      <span class="keyword">while</span>(T.right!=NULL)</div><div class="line">        T=T.right;</div><div class="line">    <span class="keyword">return</span> T;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><ul>
<li>使用Find沿着树查找，找到就做一些更新，否则将X插入到遍历的路径上的最后一个点上。</li>
<li>重复元的插入可以通过在节点记录中保留一个附加域，来指示发生的频率。</li>
</ul>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul>
<li>如果是一个树叶，立即删除。</li>
<li>如果有一个儿子，节点可以在父节点调整指针，绕过该节点后删除。</li>
<li>如果有两个儿子，用其右子树的最小的数据，代替该节点的数据，并递归的删除点。因为不可能有做儿子，所以可以按照上面一种情况处理。</li>
<li>如果删除的次数不多，可以使用<em>懒惰删除</em>。仍留在书中，只做了被删除的记号。</li>
</ul>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><ul>
<li>每个节点左子树和右子树的高度最多差1</li>
<li>不平衡情况分为四种：<ul>
<li>LL</li>
<li>LR</li>
<li>RL</li>
<li>RR</li>
</ul>
</li>
<li>其中LL和RR使用单旋转</li>
<li>LR和RL使用双旋转</li>
</ul>
<h3 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h3><ul>
<li>保证从空树开始任意连续M次对树的操作最多话费$O(MlogN)$时间。</li>
<li>当M次操作的序列总是最坏情形运行时间为$O(MF(N))$时，我们就说它摊还运行时间为$O(F(N))$。</li>
</ul>
<h5 id="简单情形"><a href="#简单情形" class="headerlink" title="简单情形"></a>简单情形</h5><ul>
<li>将在访问路径上的每一个节点和他们的父节点实施旋转。</li>
<li>并没有明显地改变原先访问路径上其他节点的情况。</li>
</ul>
<h5 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h5><ul>
<li>如果X的父节点是树根，旋转X和树根。</li>
<li>否则将X与它的父亲（P）和祖父（G）执行AVL那样的双旋转。</li>
</ul>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><ul>
<li>先序遍历——计算深度</li>
<li>后序遍历——计算高度</li>
<li>中序遍历——二叉查找树排序</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><h5 id="阶为M的B-树的定义"><a href="#阶为M的B-树的定义" class="headerlink" title="阶为M的B-树的定义"></a>阶为M的B-树的定义</h5><ul>
<li>树的根或者是一片树叶，或者其儿子数在2到M之间。</li>
<li>除根之外，所有非树叶节点的儿子数在$\lceil M/2 \rceil$ 到M之间</li>
<li>所有的树叶都在相同的深度上</li>
</ul>
<h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><ul>
<li>调整</li>
<li>首先查找只有小于M个关键字的兄弟，编程复杂，但是空间浪费少。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://learning.com/2017/05/29/ESN-basic-tutorial/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/29/ESN-basic-tutorial/" itemprop="url">
                  回声状态网络（ESN）基础教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-29T17:29:34+08:00">
                2017-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/05/29/ESN-basic-tutorial/" class="leancloud_visitors" data-flag-title="回声状态网络（ESN）基础教程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看回声状态网络（Echo State Network）的内容，注意到中文搜索引擎搜不到关于有关Echo State Network通俗的讲解，打算写一下关于ESN的一个基本教程。本文先用一小段简单介绍ESN是什么，然后用公式来表示这种网络，并说明他的优缺点，最后用一个可执行的简单例子来演示一下ESN的效果。</p>
<p>由于本人能力有限，如在阅读过程中有任何疑问或者发现错误请在评论中指出。</p>
<p>ESN是RNN的一种，也是由输入层，隐藏层，输出层组成，并且在隐藏层到隐藏层之间有一个连接，用来保留前面时刻留下的信息。不同于RNN，ESN的输入层到隐藏层、隐藏层到隐藏层的连接权值是随机初始化，并且固定不变。在训练的过程中，我们只需要去训练隐藏层到输出层的连接权值。这就变成了一个线性回归问题，所以ESN训练起来非常快。</p>
<p><img src="\images\ESN-basic-tutorial\微信截图_20170529161715.png" alt="微信截图_20170529161715"></p>
<p>ESN的神经网络如图所示，储备池就是常规神经网络中的隐藏层。输入层到储备池的连接为Win，储备池到下一个时刻储备池状态的连接为W，储备池到输出层的连接为Wout。另外还有一个前一时刻的输出层到下一个时刻的储备池的连接Wback，这个连接不是必须的（图中用虚线表示），由于这是一个入门级的基础教程，所以在后面的公式和例子代码中都不会涉及这一个连接。</p>
<p>图中所示，$t$时刻的输入为$u(t)$，一共K个节点，储备池状态为$x(t)$，N个节点，输出为$y(t)$，L个节点。</p>
<p>每一个时刻输入$u(t)$，储备池都会更新状态，储备池的状态更新方式为：</p>
<p>$$x(t+1)=f(W_{in}u(t+1)+Wx(t))$$</p>
<p>这个式子里，$W_{in}$和$W$都是在最初建立网络的时候随机初始化的，并且固定不变。$u(t+1)$是这个时刻的输入，$x(t)$是上一个时刻的储备池状态，在t=0时刻可以用0初始化。$f$是一个激活函数，通常使用$tanh$。</p>
<p>在建模的时候，和一般的神经网络一样，会在连接矩阵上加上一个偏置量，所以输入的$u$是一个长度为1+K的向量，$W_{in}$是一个[1+k,N]的矩阵，$x$是一个长度为N的向量，$W$是一个[N,N]的矩阵。</p>
<p>回声状态网络的输出方式为：</p>
<p>$$y(t)=W_{out}[1;u(t);x(t)]$$</p>
<p>有了储备池状态，再确定了ESN的输出方式之后，就可以根据目标输出$y^{target}$来确定$W_{out}$来让$y(t)$和$y^{target}(t)$的差距尽可能的小。这是一个简单的线性回归问题，计算的方法有很多种，不再赘述。</p>
<p><img src="\images\ESN-basic-tutorial\微信截图_20170529170125.png" alt="微信截图_20170529170125"></p>
<p>到这里，我们就完成了ESN的训练工作。整个网络只需要训练$W_{out}$，所以它的训练过程非常快，这是ESN的优点之一。另外，对于一维时序数列的处理和预测，ESN有很好的优势。但对于高维的时序数列，比如说视频帧处理，ESN就不太能胜任了。</p>
<p>为了让这个网络能够正常的运转，还有一些地方是需要注意的：</p>
<ol>
<li>之所以叫回声状态网络，是因为前面时刻输入的信息会通过$W$回回荡在储备池中，就像回声一样。为了避免储备池状态爆炸，$W$的特征值必须要小于等于1。这也就引入了ESN中<code>谱半径</code>的概念：$W$的最大特征值。</li>
<li>由于网络中只有$W_{out}$是可变的，为了尽可能多的表示不同的数据规律，$W$必须要设置的非常大，才能从中找出各种不同的特征进行输出。另一方面，$W$的稀疏性也很重要，Hinton在多伦多大学的公开课里解释是：</li>
</ol>
<blockquote>
<p>建立一个松散的连接，这样某一信息可以在网络中的一小部分回荡，而不会迅速的传播到其他部分。</p>
</blockquote>
<p>我不是特别的理解。希望有人解释一下。</p>
<p>最后引用<a href="http://minds.jacobs-university.de/mantas/code" target="_blank" rel="external">一个例子</a>来彻底理解最基本的ESN。</p>
<p>在页面中下载python源码和数据集，在python2.7环境中运行。</p>
<p>数据就是一维的，代码中每次输入长度为1，预测数据中后一位的值，当然长度也是1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="string">"""</span></div><div class="line">A minimalistic Echo State Networks demo with Mackey-Glass (delay 17) data </div><div class="line">in "plain" scientific Python.</div><div class="line">by Mantas LukoĹĄeviÄ?ius 2012</div><div class="line">http://minds.jacobs-university.de/mantas</div><div class="line">"""</div><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> *</div><div class="line"><span class="keyword">import</span> scipy.linalg</div><div class="line"></div><div class="line"><span class="comment"># load the data</span></div><div class="line"><span class="comment">#前2000个数据用来训练，2001-4000的数据用来测试。训练数据中，前100项用来初始化储备池，以让储备池中形成良好的回声之后再开始训练。</span></div><div class="line">trainLen = <span class="number">2000</span></div><div class="line">testLen = <span class="number">2000</span></div><div class="line">initLen = <span class="number">100</span></div><div class="line"></div><div class="line">data = loadtxt(<span class="string">'MackeyGlass_t17.txt'</span>)</div><div class="line"></div><div class="line"><span class="comment"># plot some of it</span></div><div class="line">figure(<span class="number">10</span>).clear()</div><div class="line">plot(data[<span class="number">0</span>:<span class="number">1000</span>])</div><div class="line">title(<span class="string">'A sample of data'</span>)</div><div class="line"></div><div class="line"><span class="comment"># generate the ESN reservoir</span></div><div class="line">inSize = outSize = <span class="number">1</span></div><div class="line">resSize = <span class="number">1000</span></div><div class="line">a = <span class="number">0.3</span> <span class="comment"># leaking rate 可以看作储备池更新的速度，可不不加，即设为1.</span></div><div class="line"></div><div class="line">random.seed(<span class="number">42</span>)</div><div class="line"><span class="comment">#随机初始化 Win 和 W</span></div><div class="line">Win = (random.rand(resSize,<span class="number">1</span>+inSize)<span class="number">-0.5</span>) * <span class="number">1</span></div><div class="line">W = random.rand(resSize,resSize)<span class="number">-0.5</span> </div><div class="line"><span class="comment">#对W进行防缩，以满足稀疏的要求。</span></div><div class="line"><span class="comment"># Option 1 - direct scaling (quick&amp;dirty, reservoir-specific):</span></div><div class="line"><span class="comment">#W *= 0.135 </span></div><div class="line"><span class="comment"># Option 2 - normalizing and setting spectral radius (correct, slow):</span></div><div class="line"><span class="keyword">print</span> <span class="string">'Computing spectral radius...'</span>,</div><div class="line">rhoW = max(abs(linalg.eig(W)[<span class="number">0</span>]))</div><div class="line"><span class="keyword">print</span> <span class="string">'done.'</span></div><div class="line">W *= <span class="number">1.25</span> / rhoW</div><div class="line"></div><div class="line"><span class="comment"># allocated memory for the design (collected states) matrix</span></div><div class="line">X = zeros((<span class="number">1</span>+inSize+resSize,trainLen-initLen))</div><div class="line"><span class="comment"># set the corresponding target matrix directly</span></div><div class="line">Yt = data[<span class="keyword">None</span>,initLen+<span class="number">1</span>:trainLen+<span class="number">1</span>] </div><div class="line"></div><div class="line"><span class="comment">#输入所有的训练数据，然后得到每一时刻的输入值和储备池状态。</span></div><div class="line"><span class="comment"># run the reservoir with the data and collect X </span></div><div class="line">x = zeros((resSize,<span class="number">1</span>))</div><div class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(trainLen):</div><div class="line">    u = data[t]</div><div class="line">    x = (<span class="number">1</span>-a)*x + a*tanh( dot( Win, vstack((<span class="number">1</span>,u)) ) + dot( W, x ) )</div><div class="line">    <span class="keyword">if</span> t &gt;= initLen:</div><div class="line">        X[:,t-initLen] = vstack((<span class="number">1</span>,u,x))[:,<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="comment">#使用Wout根据输入值和储备池状态去拟合目标值，这是一个简单的线性回归问题，这里使用的是岭回归(Ridge Regression)。</span></div><div class="line"><span class="comment"># train the output</span></div><div class="line">reg = <span class="number">1e-8</span>  <span class="comment"># regularization coefficient</span></div><div class="line">X_T = X.T</div><div class="line">Wout = dot( dot(Yt,X_T), linalg.inv( dot(X,X_T) + \</div><div class="line">    reg*eye(<span class="number">1</span>+inSize+resSize) ) )</div><div class="line"><span class="comment">#Wout = dot( Yt, linalg.pinv(X) )</span></div><div class="line"></div><div class="line"><span class="comment">#使用训练数据进行前向处理得到结果</span></div><div class="line"><span class="comment"># run the trained ESN in a generative mode. no need to initialize here, </span></div><div class="line"><span class="comment"># because x is initialized with training data and we continue from there.</span></div><div class="line">Y = zeros((outSize,testLen))</div><div class="line">u = data[trainLen]</div><div class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(testLen):</div><div class="line">    x = (<span class="number">1</span>-a)*x + a*tanh( dot( Win, vstack((<span class="number">1</span>,u)) ) + dot( W, x ) )</div><div class="line">    y = dot( Wout, vstack((<span class="number">1</span>,u,x)) )</div><div class="line">    Y[:,t] = y</div><div class="line">    <span class="comment"># generative mode:生成模型</span></div><div class="line">    u = y</div><div class="line">    <span class="comment">## this would be a predictive mode:预测模型</span></div><div class="line">    <span class="comment">#u = data[trainLen+t+1] </span></div><div class="line"></div><div class="line"><span class="comment"># compute MSE for the first errorLen time steps</span></div><div class="line">errorLen = <span class="number">500</span></div><div class="line">mse = sum( square( data[trainLen+<span class="number">1</span>:trainLen+errorLen+<span class="number">1</span>] - Y[<span class="number">0</span>,<span class="number">0</span>:errorLen] ) ) / errorLen</div><div class="line"><span class="keyword">print</span> <span class="string">'MSE = '</span> + str( mse )</div><div class="line">    </div><div class="line"><span class="comment"># plot some signals</span></div><div class="line">figure(<span class="number">1</span>).clear()</div><div class="line">plot( data[trainLen+<span class="number">1</span>:trainLen+testLen+<span class="number">1</span>], <span class="string">'g'</span> )</div><div class="line">plot( Y.T, <span class="string">'b'</span> )</div><div class="line">title(<span class="string">'Target and generated signals $y(n)$ starting at $n=0$'</span>)</div><div class="line">legend([<span class="string">'Target signal'</span>, <span class="string">'Free-running predicted signal'</span>])</div><div class="line"></div><div class="line">figure(<span class="number">2</span>).clear()</div><div class="line">plot( X[<span class="number">0</span>:<span class="number">20</span>,<span class="number">0</span>:<span class="number">200</span>].T )</div><div class="line">title(<span class="string">'Some reservoir activations $\mathbf&#123;x&#125;(n)$'</span>)</div><div class="line"></div><div class="line">figure(<span class="number">3</span>).clear()</div><div class="line">bar( range(<span class="number">1</span>+inSize+resSize), Wout.T )</div><div class="line">title(<span class="string">'Output weights $\mathbf&#123;W&#125;^&#123;out&#125;$'</span>)</div><div class="line"></div><div class="line">show()</div></pre></td></tr></table></figure>
<p>实验结果是再生成模型的情况下，最后得到的均方差为 2.3*10^-5。</p>
<p>生成的结果与测试结果对比图：</p>
<p><img src="\images\ESN-basic-tutorial\微信截图_20170529172248.png" alt="微信截图_20170529172248"></p>
<p>再预测模型中，均方差为6.95*10^-8。</p>
<p>预测值与真实值的对比图为：</p>
<p><img src="\images\ESN-basic-tutorial\微信截图_20170529172425.png" alt="微信截图_20170529172425"></p>
<p>效果还是肥肠好的！</p>
<p>参考文献：</p>
<p>[1] Jaeger H. The “echo state” approach to analysing and training recurrent neural networks-with an erratum note[J]. Bonn, Germany: German National Research Center for Information Technology GMD Technical Report, 2001, 148(34): 13.</p>
<p>[2] Lukoševičius M. A practical guide to applying echo state networks[M]//Neural networks: Tricks of the trade. Springer Berlin Heidelberg, 2012: 659-686.</p>
<p>[3] 罗熊, 黎江, 孙增圻. 回声状态网络的研究进展[J]. 北京科技大学学报, 2012, 34(2):217-222.</p>
<p>[4] <a href="http://minds.jacobs-university.de/mantas/code" target="_blank" rel="external">http://minds.jacobs-university.de/mantas/code</a></p>
<p>[5] <a href="https://zh.coursera.org/learn/neural-networks/lecture/s1bdp/echo-state-networks-9-min" target="_blank" rel="external">https://zh.coursera.org/learn/neural-networks/lecture/s1bdp/echo-state-networks-9-min</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://learning.com/2017/05/27/java-Integer-Object-Compare/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/27/java-Integer-Object-Compare/" itemprop="url">
                  Java中Integer类的三种初始化方式和在逻辑运算上的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-27T21:15:09+08:00">
                2017-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/05/27/java-Integer-Object-Compare/" class="leancloud_visitors" data-flag-title="Java中Integer类的三种初始化方式和在逻辑运算上的区别">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近两次遇到Integer对象比较的问题，记录一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">		Integer a = <span class="keyword">new</span> Integer(<span class="number">1200</span>);</div><div class="line">		Integer b = <span class="keyword">new</span> Integer(<span class="number">1200</span>);</div><div class="line">		<span class="keyword">int</span> c = <span class="number">1200</span>;</div><div class="line">		<span class="keyword">int</span> d = <span class="number">1200</span>;</div><div class="line">		Integer e = <span class="number">1200</span>;</div><div class="line">		Integer f = <span class="number">1200</span>;</div><div class="line">		</div><div class="line">		Integer g = <span class="number">120</span>;</div><div class="line">		Integer h = <span class="number">120</span>;</div><div class="line">				</div><div class="line">				</div><div class="line">		System.out.println(a==b); <span class="comment">//false</span></div><div class="line">		System.out.println(a.equals(b));  <span class="comment">//true</span></div><div class="line">		</div><div class="line">		System.out.println(c==d);  <span class="comment">//true</span></div><div class="line">		<span class="comment">//System.out.println(c.equals(d));</span></div><div class="line">		</div><div class="line">		System.out.println(a==d);  <span class="comment">//true</span></div><div class="line">		System.out.println(a.equals(d));  <span class="comment">//true</span></div><div class="line">		</div><div class="line">		System.out.println(e==f);  <span class="comment">//false</span></div><div class="line">		System.out.println(e.equals(f));  <span class="comment">//true </span></div><div class="line">		</div><div class="line">		System.out.println(g==h);  <span class="comment">//true</span></div><div class="line">		System.out.println(g.equals(h));  <span class="comment">//true</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>几个知识点：</p>
<ol>
<li><code>==</code> 运算符在比较两个对象时，是在比较两个对象引用。所以<code>a</code>和<code>b</code>是两个对象，第一个是<code>false</code></li>
<li><code>.equals()</code>方法需要在类中重写，以比较类中的值，在<code>Integer</code>类中，很显然比较的就是int类型的值，所以第二个是<code>true</code></li>
<li>使用基本类型时，会在内存中产生重用，所以当两次使用<code>int</code>初始化<code>c</code>和<code>d</code>时，实际上使用的是相同的地址。第三个<code>true</code></li>
<li>使用<code>==</code>比较<code>int</code>和<code>Integer</code>时，会自动拆箱，所以第四是<code>true</code>。第五个也是对的。</li>
<li>比较6和8的不同，这里要知道<code>Integer e = 1200</code>等价于<code>Integer e = Integer.valueOf(1200)</code>，看JDK的源码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">  <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">  <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">  	<span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于-128-127之间的数，会进行缓存，下次再初始化时会从缓存中取，而不是new一个。</p>
<ol>
<li>另外再补充一个，用<code>==</code>比较<code>Integer</code>和<code>new Integer</code>的时候，也不会自动拆箱，所以比较的是两个对象引用，所以是false。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://learning.com/2017/05/15/Atomic-and-nonblocking-synchronized/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/Atomic-and-nonblocking-synchronized/" itemprop="url">
                  Java并发性能提升的关键——原子变量与非阻塞同步机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-15T22:04:23+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/05/15/Atomic-and-nonblocking-synchronized/" class="leancloud_visitors" data-flag-title="Java并发性能提升的关键——原子变量与非阻塞同步机制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从这本书的最开始，就接触到原子变量类——<code>AtomicInteger</code>和<code>AtomicReference</code>用于代替锁来实现对安全性的保障。这就是从Java5.0开始的使用原子变量来提供相比较<code>synchronized</code>机制更好的性能和可伸缩性。除此之外，非阻塞的同步机制也能提供这样的良好体验。</p>
<h3 id="锁的劣势"><a href="#锁的劣势" class="headerlink" title="锁的劣势"></a>锁的劣势</h3><ol>
<li>当线程恢复执行时，必须等待其他线程执行完它们的时间片。在挂起和回复线程过程中存在着很大的开销，通常存在较长时间的中断。如果在类中操作量很小，调度开销和工作开销的比值会非常高。</li>
<li>一个线程在等待锁的时候，不能做任何事情。如果持有锁的进程被延迟执行（缺页错误，调度延迟等），其他需要这个锁的线程都无法执行下去。</li>
<li>如果被阻塞的线程优先级较高，持有锁的线程优先级较低，会产生优先级反转。</li>
<li>如果持有锁的线程被永久的阻塞（死循环，死锁，活锁等），程序永远无法执行下去。</li>
</ol>
<p>所以需要一种支持volatile变量的可见性，又支持原子性的机制。</p>
<h3 id="硬件对并发的支持"><a href="#硬件对并发的支持" class="headerlink" title="硬件对并发的支持"></a>硬件对并发的支持</h3><p>现代的处理器提供了既有volatile的可见性，又有原子性的支持。</p>
<p>早期的处理器支持原子的测试并设置(Test-and-Set)、获取并递增(Fetch-and-Increment)和交换(Swap)指令。现在几乎所有的现代处理器中都包含了<strong>原子读-改-写</strong>的指令。例如比较并交换(Compare-and-Swap)，关联加载/条件存储(Load-Linked/Store-Conditional)。</p>
<h4 id="比较并交换（CAS）"><a href="#比较并交换（CAS）" class="headerlink" title="比较并交换（CAS）"></a>比较并交换（CAS）</h4><p>CAS中包含三个操作数——需要读写的内存位置V、进行比较的值A、拟写入的新值B。V的值等于A时，用B来更新V的值，然后返回V的原有值。</p>
<p>当多个线程同时是哟个CAS更新一个变量时，只有一个线程能更新，其他线程都会失败。失败的线程不会被挂起，而是被告知失败，并可以再次尝试。</p>
<h4 id="非阻塞的计数器"><a href="#非阻塞的计数器" class="headerlink" title="非阻塞的计数器"></a>非阻塞的计数器</h4><p>使用CAS实现，读取旧值，加1，使用CAS来设置这个新值。如果CAS失败，立即重试。不会发生阻塞，但是如果多个线程同时更新，会多次执行重试。</p>
<p>在竞争程度不高时，基于CAS的计数器性能上远远超过基于锁的计数器。CAS的主要缺点是：它将使调用者处理竞争问题（重试、回退、放弃），而在锁中能自动处理竞争问题。（阻塞）</p>
<h3 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h3><ol>
<li>更新原子变量的快速路径（非竞争）不会比获取锁的快速路径慢，而它的慢速路径肯定比锁的慢速路径快，因为不需要挂起或重新调度线程。</li>
<li>在发生竞争的情况下，能提供更高的可伸缩性，因为直接利用了硬件对并发的支持。</li>
</ol>
<h3 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h3><p>在基于锁的算法中可能会发生各种活跃性故障，如果线程在持有锁时由于阻塞IO内存缺页等导致推迟执行，那么很可能所有线程都不能继续执行下去。<strong>如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。</strong></p>
<h4 id="非阻塞的栈"><a href="#非阻塞的栈" class="headerlink" title="非阻塞的栈"></a>非阻塞的栈</h4><p>push方法创建一个新的节点，该节点的next域只想当前的栈顶，然后使用CAS把这个新节点放入栈顶。如果在开始插入节点之前，位于栈顶的节点没有发生变化，那么CAS成功，如果栈顶节点发生了变化，失败，而push方法会根据栈的当前状态来更新节点，并且再次尝试。</p>
<h4 id="非阻塞的链表"><a href="#非阻塞的链表" class="headerlink" title="非阻塞的链表"></a>非阻塞的链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(E item)</span></span>&#123;</div><div class="line">  Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(item,<span class="keyword">null</span>);</div><div class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    Node&lt;E&gt; curTail = tail.get();</div><div class="line">    Node&lt;E&gt; tailNext = curTail.next.get();</div><div class="line">    <span class="keyword">if</span>(curTail == tail.get())&#123;</div><div class="line">      <span class="keyword">if</span>(tailNext!=<span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//队列处于中间状态（添加了尾节点，但是尾结点的指针没有指过去，推进尾结点）</span></div><div class="line">        tail.compareAndSet(curTail,tailNext);</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//处于稳定状态，尝试插入新节点</span></div><div class="line">        <span class="keyword">if</span>(curTail.next.compareAndSer(<span class="keyword">null</span>,newNode))&#123;</div><div class="line">          <span class="comment">//插入操作成功，尝试推进尾结点</span></div><div class="line">          tail.compareAndSer(curTail,newNode);</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://learning.com/2017/05/11/outer-sort/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/11/outer-sort/" itemprop="url">
                  《数据结构与算法设计》读书笔记——外部排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-11T20:58:07+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/05/11/outer-sort/" class="leancloud_visitors" data-flag-title="《数据结构与算法设计》读书笔记——外部排序">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上个月在某养猪场面试，面试官问了一个问题：“如何用256M内存的机器对一个2G的数据进行排序”。之前没看过这方面的内容，想了一下说用<em>归并排序</em>，然后简略的说了一下我的想法。现在再来看书里关于外部排序的内容，只能说当时的大方向没错，但是剩下的具体实现、外部空间复杂度计算、时间复杂度计算和优化等都没考虑到位。</p>
<p>因为计算机的外部访问是非常慢的（相对比从内存读数据），如果使用和“把数据全部读入内存然后排序”相同的算法，再加上外部存储例如磁带是只能顺序访问，那么任何算法都需要$\Omega(N^2)$次外部数据访问，将是非常可怕的耗时。所以需要有专门用于外部排序的算法。</p>
<p>下面首先第一部分介绍基于归并排序的简单算法，然后第二部分在简单算法的基础上让其支持多路归并可以提高效率，第三部分首先在简单算法上应用多相合并，可以节约外部存储的空间，然后扩展到多路归并上，第四部分针对用于归并的顺串进行改造，在特定的情况下可以提高算法效率。</p>
<h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><p>使用归并排序的思想，简单的双路归并需要四盘磁带（就是外部存储）。最初的数据在$T_{a1}$上，内存为M，就是每次可以使用排序算法对M个数据进行排序。</p>
<ol>
<li>依次从$T_{a1}$上读入M数据，进行排序。</li>
<li>然后交替的输出到Tb1和Tb2上。每组排过序的记录叫做一个<em>顺串</em>。</li>
<li>将 Tb1和Tb2的第一个顺串取出来将两者合并（过程参考归并算法），将结果输出到$T_{a1}$上。</li>
<li>继续上一个步骤，交替的输出到Ta1和Ta2上。直到Tb1或Tb2为空。如果剩下一个顺串，拷贝到适当的磁带上。</li>
<li>这样我们在Ta1和Ta2上得到长度为M的顺串，重复上面的过程，知道得到长度为N的顺串。</li>
</ol>
<p>示例：</p>
<p>初始状态：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th>81 94 11 96 12 35 17 99 28 58 41 75 15</th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b2}$</td>
</tr>
</tbody>
</table>
<p>第1，第2步之后：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td>11 81 94</td>
<td>17 28 99</td>
<td>15</td>
</tr>
<tr>
<td>$T_{b2}$</td>
<td>12 35 96</td>
<td>41 58 75</td>
</tr>
</tbody>
</table>
<p>第3，第4步之后：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th>11 12 35 81 94 96</th>
<th>15</th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td>17 28 41 58 75 99</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$T_{b2}$</td>
<td></td>
</tr>
</tbody>
</table>
<p>重复这个从Ta1 Ta2归并到Tb1 Tb2，从Tb1 Tb2归并到Ta1 Ta2的过程：</p>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td>11 12 17 28 35 51 58 75 81 94 96 99</td>
</tr>
<tr>
<td>$T_{b2}$</td>
<td>15</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>$T_{a1}$</th>
<th>11 12 15 17 28 35 51 58 75 81 94 96 99</th>
</tr>
</thead>
<tbody>
<tr>
<td>$T_{a2}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b1}$</td>
<td></td>
</tr>
<tr>
<td>$T_{b2}$</td>
</tr>
</tbody>
</table>
<p>完成！</p>
<p>我们“从Ta1 Ta2归并到Tb1 Tb2，从Tb1 Tb2归并到Ta1 Ta2”这个过程用了3趟。因为第一次顺串的长度为M，在二路归并的情况下，每次将顺串的长度延长一倍，需要$\lceil log_2(N/M)\rceil$趟。</p>
<h3 id="多路合并"><a href="#多路合并" class="headerlink" title="多路合并"></a>多路合并</h3><p>上面的简单算法就是二路合并，我们将其扩展到一般状态——k路合并。</p>
<p>k路合并需要2k盘磁带，每次将顺串的长度扩充为原来的k倍。在合并的时候，在k个元素中发现最小值是比二路合并复杂的地方，可以使用优先队列。多路合并和二路合并区别不大，就不举例子了。k路合并需要的趟数是$\lceil log_k(N/M)\rceil$</p>
<h3 id="多相合并"><a href="#多相合并" class="headerlink" title="多相合并"></a>多相合并</h3><p>在上面的多路合并中，k-路合并需要2k盘磁带。使用多相合并后，只使用2k-1盘磁带也可以达到相同的效果，可以节省外部存储空间。下面看如何用三盘磁带完成2-路合并：</p>
<ol>
<li>$T_1$上有34个顺串长度的数据，可以选择排序后在$T_2$$T_3$上分别输出17个顺串。</li>
<li>合并输出到$T _1$上，$T_1$上有17个顺串。</li>
<li>将8个顺串从$T_1$拷贝到$T_2$上，然后合并到$T_3$上，这时候$T_3$有9个顺串。</li>
<li>每次拷贝二分之一个顺串到一个空的磁带上，然后合并到剩下的那个空的磁带上。</li>
</ol>
<p>可以优化一下，让每次合并完成之后天然形成两个磁带有顺串，一个为空的情景：</p>
<ol>
<li>把$T_1$上的数据排序后，把21个顺串放到$T_2$上面，13个放到$T_3$上。</li>
<li>合并之后，$T_3$为空，$T_1$上有13个顺串，$T_2$上有8个顺串。</li>
<li>合并，$T_2$空，$T_3$上有8个顺串，$T_1$上有5个。重复这个过程。</li>
</ol>
<p>第一步分配的策略是：如果总顺串的数量是斐波那契数$F_N$,那么将顺串分解成F(N-1)和 F(N-2)。如果不是斐波那契数，需要用一些<em>哑顺串</em>(dummy run)来填补磁带。</p>
<p>将上面三盘磁带完成2-路合并扩展到k-路的多相合并，顺串分解使用k阶斐波那契数列：</p>
<p>$$F^{(k)}(N)=F^{(k)}(N-1)+F^{(k)}(N-2)+……+F^{(k)}(N-k)$$</p>
<p>$$F^{(k)}(N)=0,0\le k-2$$</p>
<p>$$F^{(k)}(k-1)=1$$</p>
<p>5阶斐波那契数列就是：</p>
<p>0，0，0，0，1，1，2，4，8，16，31，61……</p>
<h3 id="替换选择"><a href="#替换选择" class="headerlink" title="替换选择"></a>替换选择</h3><p>上面的排序算法中，第一步顺串的生成都使用了常规内存排序的方法，每次可以生成和内存容量一样大的有序数列。在<em>替换选择</em>算法中，无序数列平均可以生成2M长度的顺串。</p>
<ol>
<li>M个数据被读入内存，并放到一个优先队列中。执行一次DeleteMin把最小记录输出到磁带上。</li>
<li>内存空出一个位置，在从磁带读入下一个记录，如果比刚刚输出的数据要大，放入优先队列。否则把这个新元素存入优先队列的<em>死区</em>(dead space)。</li>
<li>重复上一个步骤，知道优先队列的大小为0，结束第一个顺串的构造。</li>
<li>使用死区中的所有元素建立一个新的优先队列，重复1，2，3的过程。</li>
</ol>
<p>替换选择在一些情况下，如果说大部分的数都是逆序的，效果并不比表标准算法好。但是，如果输入数据是大致顺序的，那么可以第一步就产生很长的顺串，减少来回归并的趟数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://learning.com/2017/05/11/structuring-your-TensorFlow-Model/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/11/structuring-your-TensorFlow-Model/" itemprop="url">
                  如何重构TensorFlow模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-11T20:56:34+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/05/11/structuring-your-TensorFlow-Model/" class="leancloud_visitors" data-flag-title="如何重构TensorFlow模型">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="构建你的TensorFlow模型"><a href="#构建你的TensorFlow模型" class="headerlink" title="构建你的TensorFlow模型"></a>构建你的TensorFlow模型</h2><p>翻译自：<a href="http://danijar.com/structuring-your-tensorflow-models/" target="_blank" rel="external">http://danijar.com/structuring-your-tensorflow-models/</a></p>
<p>Defining your models in TensorFlow can easily result in one huge wall of code. How to structure your code in a readable and reusable way? For the inpacient of you, here is the link to a <a href="https://gist.github.com/danijar/8663d3bbfd586bffecf6a0094cd116f2" target="_blank" rel="external">working example gist</a>.</p>
<p>第一句话不会翻译”wall of code”，算了，这不重要。</p>
<h3 id="定义计算图-Compute-Graph"><a href="#定义计算图-Compute-Graph" class="headerlink" title="定义计算图(Compute Graph)"></a>定义计算图(Compute Graph)</h3><p>每个模型使用一个类作为开始是非常明智的。类的接口是什么？通常，你的模型连接一些输入数据和目标<code>placeholders</code>，并且提供训练、测试的操作和接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, target)</span>:</span></div><div class="line">        data_size = int(data.get_shape()[<span class="number">1</span>])</div><div class="line">        target_size = int(target.get_shape()[<span class="number">1</span>])</div><div class="line">        <span class="comment">#truncated_normal返回正态分布的随机值</span></div><div class="line">        weight = tf.Variable(tf.truncated_normal([data_size, target_size]))</div><div class="line">        bias = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[target_size]))</div><div class="line">        incoming = tf.matmul(data, weight) + bias</div><div class="line">        self._prediction = tf.nn.softmax(incoming)</div><div class="line">        <span class="comment">#计算交叉熵，reduce_sum还能这样用？和文档写的不一样啊。</span></div><div class="line">        cross_entropy = -tf.reduce_sum(target, tf.log(self._prediction))</div><div class="line">        <span class="comment">#使用RMSPropOptimizer以0.03为learning rate最小化交叉熵</span></div><div class="line">        self._optimize = tf.train.RMSPropOptimizer(<span class="number">0.03</span>).minimize(cross_entropy)</div><div class="line">        mistakes = tf.not_equal(</div><div class="line">            tf.argmax(target, <span class="number">1</span>), tf.argmax(self._prediction, <span class="number">1</span>))</div><div class="line">        <span class="comment">#求平均误差</span></div><div class="line">        self._error = tf.reduce_mean(tf.cast(mistakes, tf.float32))</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prediction</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._prediction</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._optimize</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._error</div></pre></td></tr></table></figure>
<p>这基本上是在TensorFlow中定义模型的基础代码。但是他有一些问题。最值得注意的是，这个图在单个函数（构造函数）中定义，非常不具备可读性和可重用性。</p>
<h3 id="使用属性"><a href="#使用属性" class="headerlink" title="使用属性"></a>使用属性</h3><p>仅仅将代码分割在函数中是不行的，因为每次函数被调用的时候，图都会被新的代码扩展。因此，我们需要确保这些操作只有在函数第一次调用的时候才添加到图里面。这就是基本的惰性加载。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, target)</span>:</span></div><div class="line">        self.data = data</div><div class="line">        self.target = target</div><div class="line">        self._prediction = <span class="keyword">None</span></div><div class="line">        self._optimize = <span class="keyword">None</span></div><div class="line">        self._error = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prediction</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._prediction:</div><div class="line">            data_size = int(self.data.get_shape()[<span class="number">1</span>])</div><div class="line">            target_size = int(self.target.get_shape()[<span class="number">1</span>])</div><div class="line">            weight = tf.Variable(tf.truncated_normal([data_size, target_size]))</div><div class="line">            bias = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[target_size]))</div><div class="line">            incoming = tf.matmul(self.data, weight) + bias</div><div class="line">            self._prediction = tf.nn.softmax(incoming)</div><div class="line">        <span class="keyword">return</span> self._prediction</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._optimize:</div><div class="line">            cross_entropy = -tf.reduce_sum(self.target, tf.log(self.prediction))</div><div class="line">            optimizer = tf.train.RMSPropOptimizer(<span class="number">0.03</span>)</div><div class="line">            self._optimize = optimizer.minimize(cross_entropy)</div><div class="line">        <span class="keyword">return</span> self._optimize</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._error:</div><div class="line">            mistakes = tf.not_equal(</div><div class="line">                tf.argmax(self.target, <span class="number">1</span>), tf.argmax(self.prediction, <span class="number">1</span>))</div><div class="line">            self._error = tf.reduce_mean(tf.cast(mistakes, tf.float32))</div><div class="line">        <span class="keyword">return</span> self._error</div></pre></td></tr></table></figure>
<p> 这比第一个例子中的代码好多了。你的代码现在被构建在函数中，你现在可以分别关注他们。但是，由于延迟加载逻辑，代码仍然有一些臃肿。下面让我们改正它。</p>
<h3 id="惰性属性装饰器"><a href="#惰性属性装饰器" class="headerlink" title="惰性属性装饰器"></a>惰性属性装饰器</h3><p>python是一个相当灵活的语言。现在让我想你展示如何剔除上一段代码中的冗余代码。我们将使用一个行为就像<code>@property</code>一样的装饰器，但是只执行函数一次。他会在被装饰的函数后面将结果储存在一个命名成员中，而且后面的调用中返回结果。如果你还没有用过自定义装饰器，你可能需要看一下这个<a href="http://blog.apcelent.com/python-decorator-tutorial-with-example.html" target="_blank" rel="external">教程</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_property</span><span class="params">(function)</span>:</span></div><div class="line">    attribute = <span class="string">'_cache_'</span> + function.__name__</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line"><span class="meta">    @functools.wraps(function)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, attribute):</div><div class="line">            setattr(self, attribute, function(self))</div><div class="line">        <span class="keyword">return</span> getattr(self, attribute)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p>使用这个装饰器后，我们的例子简化成为下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, target)</span>:</span></div><div class="line">        self.data = data</div><div class="line">        self.target = target</div><div class="line">        self.prediction</div><div class="line">        self.optimize</div><div class="line">        self.error</div><div class="line"></div><div class="line"><span class="meta">    @lazy_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prediction</span><span class="params">(self)</span>:</span></div><div class="line">        data_size = int(self.data.get_shape()[<span class="number">1</span>])</div><div class="line">        target_size = int(self.target.get_shape()[<span class="number">1</span>])</div><div class="line">        weight = tf.Variable(tf.truncated_normal([data_size, target_size]))</div><div class="line">        bias = tf.Variable(tf.constant(<span class="number">0.1</span>, shape=[target_size]))</div><div class="line">        incoming = tf.matmul(self.data, weight) + bias</div><div class="line">        <span class="keyword">return</span> tf.nn.softmax(incoming)</div><div class="line"></div><div class="line"><span class="meta">    @lazy_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(self)</span>:</span></div><div class="line">        cross_entropy = -tf.reduce_sum(self.target, tf.log(self.prediction))</div><div class="line">        optimizer = tf.train.RMSPropOptimizer(<span class="number">0.03</span>)</div><div class="line">        <span class="keyword">return</span> optimizer.minimize(cross_entropy)</div><div class="line"></div><div class="line"><span class="meta">    @lazy_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></div><div class="line">        mistakes = tf.not_equal(</div><div class="line">            tf.argmax(self.target, <span class="number">1</span>), tf.argmax(self.prediction, <span class="number">1</span>))</div><div class="line">        <span class="keyword">return</span> tf.reduce_mean(tf.cast(mistakes, tf.float32))</div></pre></td></tr></table></figure>
<p>注意，我们提到构造函数中的属性。这样可以确保完整的图在我们执行<code>tf.initialize_variables()</code>时被定义。</p>
<h3 id="通过命名空间组织图"><a href="#通过命名空间组织图" class="headerlink" title="通过命名空间组织图"></a>通过命名空间组织图</h3><p>我们现在已经有一个清晰的方式去定义我们的模型，但是导致计算图非常拥挤。如果你想对图进行可视化，他将会有用很多互联的小节点。现在要在每个函数外面包裹<code>tf.name_scope(&#39;name&#39;)</code>或者<code>tf.varizble_scope(&#39;name&#39;)</code>。节点将会在图中分组。我们可以调整我们前面的装饰器去自动实现这些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">define_scope</span><span class="params">(function)</span>:</span></div><div class="line">    attribute = <span class="string">'_cache_'</span> + function.__name__</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line"><span class="meta">    @functools.wraps(function)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, attribute):</div><div class="line">            <span class="keyword">with</span> tf.variable_scope(function.__name):</div><div class="line">                setattr(self, attribute, function(self))</div><div class="line">        <span class="keyword">return</span> getattr(self, attribute)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p>我给这个装饰器一个新的名字（define_scope），因为除了添加惰性缓存之外他还有针对RensorFlow的特定功能。除此之外，这个模型看上去和前一个一样。</p>
<p>我们可以进一步的允许<code>@define_scope</code>装饰器forward arguments to the <code>tf.variable_scope()</code>，例如定义一个命名空间内的默认的初始化器(initializer)。可以参考作者上传的完整版代码：<a href="https://gist.github.com/danijar/8663d3bbfd586bffecf6a0094cd116f2" target="_blank" rel="external">https://gist.github.com/danijar/8663d3bbfd586bffecf6a0094cd116f2</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://learning.com/2017/05/05/avoid-deadlock/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zhuo Jimmy">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="jlearning.cn">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="jlearning.cn" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/05/avoid-deadlock/" itemprop="url">
                  《Java并发编程实战》读书笔记——避免活跃性问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-05T16:45:17+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/05/05/avoid-deadlock/" class="leancloud_visitors" data-flag-title="《Java并发编程实战》读书笔记——避免活跃性问题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了让并发程序安全，会选择加锁。但是过度、不恰当的加锁会导致“锁顺序死锁”。同样，使用线程池和信号量来限制对资源的使用，这些被限制的行为可能导致“资源死锁”。这一章会主要介绍死锁的分类，主要根据死锁产生的原因进行分类。和如何避免和诊断死锁。最后介绍死锁之外的其他活跃性风险，比如说饥饿等。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>一个资源每次只能被一个人使用（互斥条件），每个人都拥有其他人需要的资源，同时又等待其他人已经拥有的资源（请求与保持条件），并且在每个人在获得所有需要的资源之前都不放弃已经拥有的资源（不剥夺条件）。（循环等待）就产生了死锁。</p>
<h4 id="锁顺序死锁"><a href="#锁顺序死锁" class="headerlink" title="锁顺序死锁"></a>锁顺序死锁</h4><p>两个线程试图用不同的顺序来获得相同的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadLock</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(left)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(right)&#123;</div><div class="line">        doSomething();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(right)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(left)&#123;</div><div class="line">        doSomethind();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要想验证锁顺序的一致性，需要对程序中的加锁行为进行全局分析。</p>
<h4 id="动态的锁顺序死锁"><a href="#动态的锁顺序死锁" class="headerlink" title="动态的锁顺序死锁"></a>动态的锁顺序死锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount, Account toAccount, DollarAmount amount)</span></span></div><div class="line">  <span class="keyword">throws</span> InsufficientFundsException&#123;</div><div class="line">    <span class="keyword">synchronized</span>(fromAccount)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(toAccount)&#123;</div><div class="line">        <span class="keyword">if</span>(fromAccount.getBalance().comparaTo(amount)&lt;<span class="number">0</span>)</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">          fromAccount.debit(amount);</div><div class="line">          toAccount.credit(amount);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>虽然锁顺序都是先取得<code>fromAccount</code>的锁，在取得<code>toAccount</code>的锁，但是事实上上锁的顺序取决于传递给函数的参数的顺序。</p>
<p>这种死锁可以通过制定锁的顺序来解决。使用<code>System.identityHashCode</code>方法，每次先获得<code>hashCode</code>小的那个对象的锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object tieLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMonet</span><span class="params">(<span class="keyword">final</span> Account fromAcct,<span class="keyword">final</span> Account toAcct, <span class="keyword">final</span> DollarAmount amount)</span> <span class="keyword">throws</span> insufficientFundsException</span>&#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Helper</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> <span class="keyword">throws</span> InsufficientFundsException</span>&#123;</div><div class="line">      <span class="keyword">if</span>(fromAcct.getBalance().comparaTo(amount)&lt;<span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> insufficientFundsException();</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        fromAcct.debit(amount);</div><div class="line">        toAcct.credit(amount);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">int</span> fromHash = System.identityHashCode(fromAcct);</div><div class="line">  <span class="keyword">int</span> toHash = System.identityHashCode(toAcct);</div><div class="line">  </div><div class="line">  <span class="keyword">if</span>(fromHash&lt;toHash)&#123;</div><div class="line">    <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">        <span class="keyword">new</span> Helper().transfer();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(from Hash&gt;toHash)&#123;</div><div class="line">    <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">        <span class="keyword">new</span> Helper().transfer();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//极少数的情况下，两个对象拥有相同的散列值，此时通过另一个锁保证每次只有一个线程以位置的顺序获得这两个锁。如果经常出先散列冲突的情况，这个地方因为相当于给整个程序加一个锁，会成为性能瓶颈。</span></div><div class="line">    <span class="keyword">synchronized</span>(tieLock)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(toAcct)&#123;</div><div class="line">        <span class="keyword">synchronized</span>(fromAcct)&#123;</div><div class="line">          <span class="keyword">new</span> Helper().transfer();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果每个账户都包含唯一不可变的可比的键值，会更简单，不用比较散列值。</p>
<h4 id="在协作对象之间发生的死锁"><a href="#在协作对象之间发生的死锁" class="headerlink" title="在协作对象之间发生的死锁"></a>在协作对象之间发生的死锁</h4><p>在持有锁的情况下调用某个外部方法，这个外部方法中可能会获取其他锁。可能会像锁顺序死锁一样。</p>
<h4 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h4><p>如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。</p>
<p>使用同步代码块仅被用于保护那些设计共享状态的操作。</p>
<h4 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h4><p>如果某些任务需要等待其他任务的结果，妈么这些任务往往是产生线程饥饿死锁的主要来源。</p>
<h3 id="死锁的避免与诊断"><a href="#死锁的避免与诊断" class="headerlink" title="死锁的避免与诊断"></a>死锁的避免与诊断</h3><p>如果程序每次最多只获得一个锁，那么就不会发生死锁。但是不现实。所以应该在设计时考虑锁的顺序，尽量减少潜在的加锁交互数量。</p>
<p>两阶段策略（Two-Part Strategy）：</p>
<ul>
<li>找出在什么地方将获取多个锁。</li>
<li>多所有这些实例进行全局分析，确保他们在整个程序中获取锁的顺序都是一致的。</li>
</ul>
<h4 id="支持定时的锁"><a href="#支持定时的锁" class="headerlink" title="支持定时的锁"></a>支持定时的锁</h4><p>显式使用Lock类中的定时tryLock功能来代替内置锁机制。显式锁可以指定一个超时时限，等待超过该事件后会返回一个失败信息。</p>
<h4 id="通过线程转储（Thread-Dump）信息来分析死锁"><a href="#通过线程转储（Thread-Dump）信息来分析死锁" class="headerlink" title="通过线程转储（Thread Dump）信息来分析死锁"></a>通过线程转储（Thread Dump）信息来分析死锁</h4><h3 id="其他活跃性问题"><a href="#其他活跃性问题" class="headerlink" title="其他活跃性问题"></a>其他活跃性问题</h3><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>当前线程由于无法访问它需要的资源而不能继续执行，就发生了饥饿。最典型的是由于错误的使用线程优先级，导致获取不到CPU时钟周期。</p>
<h4 id="糟糕的响应性"><a href="#糟糕的响应性" class="headerlink" title="糟糕的响应性"></a>糟糕的响应性</h4><p>CPU密集型后台任务与事件线程竞争CPU的时钟周期，从而影响响应性。</p>
<p>可以通过降低后台任务的优先级解决这个问题。</p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>错误的将不可修复的错误作为可修复的错误，导致如果不能成功处理某个消息，那么就回滚并重新放到队列开头，反复调用返回相同的结果。</p>
<p>当多个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行。就发生了活锁。</p>
<p>需要在重试机制中引入随机性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          
    
        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Zhuo Jimmy" />
          <p class="site-author-name" itemprop="name">Zhuo Jimmy</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">32</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2116491901" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:zhuo_jimmy@yeah.net" target="_blank" title="email">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/49178609/" target="_blank" title="����">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  ����
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhuo Jimmy</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  



  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("HFHaSh6qpS4jVESzHUkGA3wi-gzGzoHsz", "5zRJEDM6Mbkh4tIGz0kaI6Vl");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
